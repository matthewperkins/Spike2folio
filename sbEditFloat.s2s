#include "include\basic_view.s2s"     'this will bring in two globals: GVt% and GChanList%[]

'SELECT CHANNELS FOR EDITING 

var SlctChn%[31];
var EvntChn%[31];
var MemChns%[31];
var JmpChn%[2]; 

Interact("Select (events) chans chan to edit", 1023, 0, "&O Okay");
ChngEdtChns%();

Interact("Select a single event chan to for jumping", 1023, 0, "&O Okay");
SetJmpChn%();


'use marker code 0 0 0 0 for condition start
var startcode%[4];
ArrConst(startcode%[], 0);
                                                
'use marker code 1 0 0 0 for condition END
var endcode%[4];
ArrConst(endcode%[], 0);
endcode%[0] := 1;

'PUT LABELED CURSORS IN VIEW
var FeatureCurs%;
CursorDelete(-1);
FeatureCurs% := CursorNew();
CursorLabel(4, FeatureCurs%,"Feature Cursor"); 
CursorLabelPos(FeatureCurs%,50);
makeeventcursors(3);

ToolbarClear();
ToolbarSet(13, "G JmpChn||Set a channel for jumping around", SetJmpChn%);
ToolbarSet(12, "&C Chng||Change set of channels you are editing, highlight then click", ChngEdtChns%);
ToolbarSet(11, "&U DlBtwn||Delete between del1 and del2", delspksbtw%);
ToolbarSet(10, "&N MkEnd||Make End: make the mark nrst featr crs an end", MkEnd%);
ToolbarSet(9, "&Y  MkStr||Make Start: make the mark nearest the feature cursor a start", MkStart%);
ToolbarSet(8 , "&J frwd||jump forward", nexttest%);
ToolbarSet(7 , "&K rvsr||jump backward", lasttest%);
ToolbarSet(6 , "&F frwd||draw forward", forwarddraw%);
ToolbarSet(5 , "&R rvsr||draw backward", backwarddraw%);
ToolBarSet(4 , "&E addSTART||Add Condition Start at Cursor", AddCondStart%);
ToolBarSet(3 , "&P addEND||Add a Condition End at Cursor", AddCondEnd%);
ToolBarSet(2 , "&I del||Delete last Feature Item before Feature Cursor", Del%);
ToolBarSet(1 , "&L save||save eventchannels and leave",outie%);
ToolbarEnable(1,1);
Toolbar("",1);

''''''''''''''''''FUNCS AND PROCS FOR SELECTING CHANS'''''''''''''''
''' non memchannel are copied to a mem channel than original is deleted
''' they are not saved again on exit

proc GrbEvntChns(SlctChn%[], EvntChn%[]);
    var i%, kind%, NmEvChns% := 0;
    ChanList(SlctChn%[], 65536);
    for i% := 1 to SlctChn%[0] do
        if (IsEvntLk%(SlctChn%[i%])) then
            NmEvChns% := NmEvChns% + 1;
            EvntChn%[0] := NmEvChns%;
            EvntChn%[NmEvChns%] := SlctChn%[i%];
        endif;
    next;
end;
    
func IsEvntLk%(chan%)
    var kind%;
    kind% := ChanKind(chan%);
    docase
        case kind%=2 then return 1;
        case kind%=2 then return 1;
        case kind%=4 then return 1;
        case kind%=5 then return 1;
        case kind%=8 then return 1;
        else return 0;
    endcase;
end;

proc DupDelNonMem(ChanSpc%[],MemChans%[]);
    var i%;
    MemChans%[0] := ChanSpc%[0];
    for i% := 1 to ChanSpc%[0] do
        if ChanSpc%[i%]<400 then
            MemChans%[i%] := CopyWave%(ChanSpc%[i%]);
            ChanDelete(ChanSpc%[i%]);
        else
            MemChans%[i%] := ChanSpc%[i%];
        endif;
    next;
    ChanShow(MemChans%[]);
end
    
func CopyWave%(chan%) 
    var mc%;
    mc% := MemChan(0, chan%);                'Create waveform channel
    if mc%>0 then                            'Created OK?
       ChanComment$(mc%, "Copy of channel "+Str$(chan%));
       MemImport(mc%, chan%, 0, MaxTime());  'Copy data
       ChanShow(mc%);                        'display new channel
    endif;
    return mc%; 'Return the new memory channel number
end;

proc ChngClr(cSpc%[], clr%)
    var i%;
    for i% := 1 to cSpc%[0] do
        ChanColour(cSpc%[i%], 1, clr%);
    next;
end;


'''''''''''''''''TOOLBAR FUNCTIONS ''''''''''''''''''''''
'THESE WILL WORK ON THE GLOBAL Cspc%[] MemChan%[]
'NOTE THESE DEPEND ON SOME OTHER GLOBELS
var MarkFeature%;

func MkEnd%()
var i%;
var cur1, before, after, closest;
cur1 := Cursor(FeatureCurs%);
for i% := 1 to MemChns%[0] do
    after := NextTime(MemChns%[i%], cur1);
    before := LastTime(MemChns%[i%], cur1);
    if ((after - cur1) < (cur1-before)) then 
        closest := after 
    else 
        closest := before 
    endif;
    if (cur1 - closest<4) then
        MarkEdit(MemChns%[i%], closest, endcode%[]);
        return(1);
    else
        return(1);
    endif;
next;
end

func MkStart%()
    var cur1, before, after, closest, i%;
    cur1 := Cursor(FeatureCurs%);
    for i% := 1 to MemChns%[0] do
        after := NextTime(MemChns%[i%], cur1);
        before := LastTime(MemChns%[i%], cur1);
        if ((after - cur1) < (cur1-before)) then 
            closest := after 
        else 
            closest := before 
        endif;
        if (cur1 - closest<4) then
            MarkEdit(MemChns%[i%], closest, startcode%[]);
            return(1);
        else
            return(1);
        endif;
    next;
end
    
func forwarddraw%()
var ttmp, rngtmp;
    'FIND RELATIVE POSITIONS OF CURSORS
    var RelPosFeat, RelPosDel, RelPosDel2;
    RelPosFeat := Cursor(FeatureCurs%) - XLow();
    RelPosDel := Cursor(8) - XLow();
    RelPosDel2 := Cursor(9) - XLow();
    
    rngtmp := XHigh()-XLow();
    ttmp := XLow() + rngtmp*0.1;
    Cursor(FeatureCurs%,(ttmp+RelPosFeat));
    Cursor(8,(ttmp+RelPosDel));Cursor(9,(ttmp+RelPosDel2));
    Draw(ttmp);
return(1);
end

func backwarddraw%()
var ttmp, rngtmp;
    'FIND RELATIVE POSITIONS OF CURSORS
    var RelPosFeat, RelPosDel, RelPosDel2;
    RelPosFeat := Cursor(FeatureCurs%) - XLow();
    RelPosDel := Cursor(8) - XLow();
    RelPosDel2 := Cursor(9) - XLow();

    rngtmp := XHigh()-XLow();
    ttmp := XLow() - rngtmp*0.1;
    Cursor(FeatureCurs%,(ttmp+RelPosFeat));
    Cursor(8,(ttmp+RelPosDel));Cursor(9,(ttmp+RelPosDel2));
    Draw(ttmp);
return(1);
end

func AddCondStart%()
    var FeaCurTime, i%;
    FeaCurTime := Cursor(FeatureCurs%);
    for i% := 1 to MemChns%[0] do
        MemSetItem(MemChns%[i%],0,FeaCurTime, startcode%[]);
    next;
    Draw();
    return(1);
end

func AddCondEnd%()
    var FeaCurTime, i%;
    FeaCurTime := Cursor(FeatureCurs%);
    for i% := 1 to MemChns%[0] do
        MemSetItem(MemChns%[i%],0, FeaCurTime, endcode%[]);
    next;
    Draw();
    return(1);
end

func Del%()
    var FeaCurTime, numitems%, i%;
    FeaCurTime := Cursor(FeatureCurs%);
    for i% := 1 to MemChns%[0] do
        MemDeleteTime(MemChns%[i%], 0, FeaCurTime, 4);
    next;
    Draw();
return(1);
end

func delspksbtw%()
var i%;
    for i% := 1 to MemChns%[0] do
        MemDeleteTime(MemChns%[i%],3,Cursor(8),Cursor(9));
    next;
    Draw();
return(1);
end

func nexttest%()
    'want to save cursor position relative to window
    'then redraw them at the same relative position after jumping window
    var RelPosFeat, RelPosDel, RelPosDel2;
    RelPosFeat := Cursor(FeatureCurs%) - XLow();
    RelPosDel := Cursor(8) - XLow();
    RelPosDel2 := Cursor(9) - XLow();

    'want to save window position relative to the start of the test
    'then redraw new window at same relative position
    'if there is no exct test start mark in view, default to 20 % offset
    var RelPosWin, rngtmp;
    rngtmp := XHigh() - XLow();
    RelPosWin := XLow() - NextTime(MarkFeature%, XLow(), startcode%);
    if (Abs(RelPosWin) > rngtmp) then
        RelPosWin := rngtmp * -0.2;
    endif;

    'find next time and draw window and cursors
    var ttmp;
    ttmp := GetNextExctCode(MarkFeature%, XLow(), startcode%);
    ttmp := GetNextExctCode(MarkFeature%, ttmp, startcode%);
    ttmp := ttmp + RelPosWin;
    Cursor(FeatureCurs%,(ttmp+RelPosFeat));
    Cursor(8,(ttmp+RelPosDel));Cursor(9,(ttmp+RelPosDel2));
    Draw(ttmp);
    return(1);
end

func lasttest%()
    'want to save cursor position relative to window
    'then redraw them at the same relative position after jumping window
    var RelPosFeat, RelPosDel, RelPosDel2;
    RelPosFeat := Cursor(FeatureCurs%) - XLow();
    RelPosDel := Cursor(8) - XLow();
    RelPosDel2 := Cursor(9) - XLow();

    'want to save window position relative to the start of the test
    'then redraw new window at same relative position
    'if there is no exct test start mark in view, default to 20 % offset
    var RelPosWin, rngtmp;
    rngtmp := XHigh() - XLow();
    RelPosWin := XLow() - NextTime(MarkFeature%, XLow(), startcode%[]);
    if (Abs(RelPosWin) > rngtmp) then
        RelPosWin := rngtmp * -0.2;
    endif;


    'find next time and draw window and cursors
    var ttmp;
    ttmp := GetLastExctCode(MarkFeature%, XLow(), startcode%[]);
    ttmp := ttmp + RelPosWin;
    Cursor(FeatureCurs%,(ttmp+RelPosFeat));
    Cursor(8,(ttmp+RelPosDel));Cursor(9,(ttmp+RelPosDel2));
    Draw(ttmp);
    return(1);
end

func ChngEdtChns%()
    ChngClr(MemChns%,1);
    ArrConst(EvntChn%[], 0); ArrConst(MemChns%,0);
    GrbEvntChns(SlctChn%[], EvntChn%[]);
    DupDelNonMem(EvntChn%[], MemChns%[]);
    ChngClr(MemChns%[],16);
    return(1);
end

func SetJmpChn%()
    ChanList(JmpChn%[], 65536);
    ChngClr(JmpChn%[], 20);
    MarkFeature% := JmpChn%[1];
    return(1);
end

func outie%()
    return(0);
end

func GetNextExctCode(chan%, time, code%[])
    var nextcode%[4];
    var codematch% := 1; 'codematch will be zero when match found
    while (codematch%=1) do
        time := NextTime(chan%,time,nextcode%);
        ArrSub(nextcode%[], code%[]);
        codematch% := ArrSum(nextcode%[]);
        if (time=-1) then break endif;
    wend;
    return time
end

func GetLastExctCode(chan%, time, code%[])
    var nextcode%[4];
    var codematch% := 1; 'codematch will be zero when match found
    while (codematch%=1) do
        time := LastTime(chan%,time,nextcode%);
        ArrSub(nextcode%[], code%[]);
        codematch% := ArrSum(nextcode%[]);
        if (time=-1) then break endif;
    wend;
    return time
end

Proc makeeventcursors(n%)
    var i%, range := XHigh()-XLow();
    var divi, divn := n%;
    var startcurnum% := 9-n%;
    for i% := 1 to n% do
        divi := i%;
        CursorNew(XLow()+(range*0.8*(divi/divn)), startcurnum%+i%);
    next
    CursorLabel(4, 8,"delete1"); CursorLabelPos(2,20);
    CursorLabel(4, 9,"delete2"); CursorLabelPos(3,20);
end
