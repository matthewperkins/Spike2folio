'want to count number of spikes during protraction and retraction
var numchans%, chansarry%[10], ChanNames$[10], viewsarry%[10], whchchantmp%, avgfreqtmp, latencytmp, peakfreqtmp;
var prostartchan%, proendchan%, reendchan%,enstimchan%;
var psholder, peholder, reholder;
var tmpmp[3];
var i%, j%;

'HANDLE VIEWS
var viewtemp%;
viewtemp% := View(0);  'Save the current view
View(viewtemp%);         'restore the original view
DrawAll();
FrontView(viewtemp%);

'PLACE HOLDERS FOR MP CHANNELS
psholder := 1;
peholder := 1;
reholder := 1;

'DESIGNATE MPCHANNELS AND CELL CHANNELS
var nomprostartchan%, nomproendchan%, nomreendchan%, nomstimstartchan%, stimstartchan%;
nomprostartchan%:= Input("What channel\n is protraction start mark?", 401);
nomproendchan% := Input("What channel\n is protraction end mark?", 402);
nomreendchan% := Input("What channel\n is retraction end mark?", 403);
nomstimstartchan% := Input("What channel\n is stim start mark?", 405);

prostartchan%:= MemChan(0, nomprostartchan%);
proendchan% := MemChan(0, nomproendchan%);
reendchan% := MemChan(0, nomreendchan%);
stimstartchan% := MemChan(0, nomstimstartchan%);
MemImport(prostartchan%,nomprostartchan%,0,MaxTime());
MemImport(proendchan%,nomproendchan%,0,MaxTime());
MemImport(reendchan%,nomreendchan%,0,MaxTime());
MemImport(stimstartchan%,nomstimstartchan%,0,MaxTime());

numchans% := Input("how many event channels?", 4);
enstimchan% := Input("give me a neurogram channel\n with a large artifact\n relative to its signal\nGIVE ZERO IF YOU HAVE YOUR\n OWN STIMSTART CHAN?", 11);

'NEW FILES / CELL CHANNELS / ONE FILE PER CELL
'SPECIFY FILE FORM HERE, THIS IS SOME DAGRON IT STUFF
var fname$, rdirstring$, NumHeaders%;
'HAVE TO SPECIFY THE NUMBER OF HEADERS IN THE FILE FORMATE MANUALLY!!!'
NumHeaders% := 4;
fname$ := Print$("%s%s",FileName$(3),FileName$(4));
rdirstring$ := Print$("%s\%s\%s%s",FileName$(1),FileName$(2),"..\\all_cells");

for i% := 1 to numchans% do
    View(viewtemp%);
    FrontView(viewtemp%);
    DrawAll();
    chansarry%[i%-1] := Input(Print$("%g st channel",i%), 1);
    ChanNames$[i%-1] := ChanTitle$(chansarry%[i%-1]);
    viewsarry%[i%-1] := FileNew(1);
    Print("num_headers,%g,\n", NumHeaders%);
    Print("file_name,%s,\n",fname$);
    Print("cell_name,%s,\n",ChanNames$[i%-1]);
    Print("pro_start,");
    Print("pro_end,");
    Print("re_end,");
    Print("avg_freq_p,");
    Print("laten_p,");
    Print("avg_freq_r,");
    Print("laten_r,");
    Print("num_spk_p,");
    Print("times_spk_p\n");
    View(viewtemp%);    
    DrawAll();
next

'MAKE ENSTIMBLOCKS WITH BURSTMAKE
var outburstchan%, enblockstarts, memchanstim%;
memchanstim% := MemChan(2);
'TEST TO SEE IF USR HAS OWN STIM CHAN
if enstimchan% = 0 then
    outburstchan% := stimstartchan%;
else
    memchanstim% := findstimulusstart(enstimchan%);
    outburstchan% := makeenstimblocks(memchanstim%);
    MarkMask(outburstchan%, 0, 0, 1); 'excludes stimblock endings from the outburstchan, leaving only starts 
endif;

func findstimulusstart(n%)
    var stimevent%, enthresh;
    var append$ := "sVNT";
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, 0, MaxTime(), 2, 0, enthresh);
    return stimevent%
end

func findsixsigma(n%)
    var mean, sdd, thresh;
    mean := ChanMeasure(n%,2,0,MaxTime());
    sdd  := ChanMeasure(n%,12,0,MaxTime());
    thresh := mean + (6*sdd);
    return thresh;
end

func makeenstimblocks(enstimvntchan%)
    var burstchan%, maxisi, minnumstims;
    maxisi := 1; 'the maximum allowable inter stimulus interval in seconds allowed in a single block of en stim
    minnumstims := 30; 'min number of events to be considered a burst
    burstchan% := MemChan(5);
    BurstMake(burstchan%, enstimvntchan%, 0, MaxTime(), maxisi, maxisi, minnumstims);
    return burstchan%
end

'LOOP THRU EVENTS ON PROTRACTION START CHANNEL
for i% := 1 to MemGetItem(prostartchan%) do
    filltmpmp();
    for j% := 1 to numchans% do
        printavglatpeakarry(chansarry%[j%-1],viewsarry%[j%-1]);
    next
next

'SAVE / CLOSE FILES
var outchanname$; 
for j% := 1 to numchans% do
    View(viewtemp%);
    outchanname$ := Print$("%s_%s.csv",fname$, ChanTitle$(chansarry%[j%-1]));
    View(viewsarry%[j%-1]);
    FilePathSet(rdirstring$); FileSaveAs(outchanname$,1); FileClose();
next

'CLEAN UP DELETE MEMORY CHANNELS MADE
ChanDelete(prostartchan%);
ChanDelete(proendchan%);
ChanDelete(reendchan%);
ChanDelete(memchanstim%);
ChanDelete(outburstchan%);

'
'
'
'FUNCTIONS/PROCS BELOW
'FILLS VECTOR WITH NEXT MOTOR PROGRAM TIMES
proc filltmpmp()
    tmpmp[0] := MemGetItem(prostartchan%, psholder);
    tmpmp[1] := MemGetItem(proendchan%, peholder);
    tmpmp[2] := MemGetItem(reendchan%, reholder);
    psholder := psholder + 1;
    peholder := peholder + 1;
    reholder := reholder + 1;
end

'PRINTS TO CSV EVENT INFORMATION IN A SINGLE MOTOR PROGRAM (TMPMP[PROSTART, PROEND, REEND])
'FORM IS:
'pro_start, proend, reend, avg_freq_pro, lat_fspk_pro, avg_freq_re, lat_fspk_re, num_spks_pr, \
'... time_each_spk_pro, num_spks_re, time_each_spk_re
'If there are no spikes in pro or retract, the latency is a blank cell, and the time_each_spk is one blank cell
func printavglatpeakarry(chan%,vh%)
    var divnumpsks, divnumrspks, TestData[10];
    var proavg, prolat, reavg, relat, pspksarry[4000], rspksarry[4000]; 
    var numpspks%, numrspks%, normpros, normproe, normre;
    var absprostart, absproend, absreend;
    ChanData(outburstchan%, TestData[],0, MaxTime());
    absprostart := tmpmp[0];
    absproend := tmpmp[1];
    absreend := tmpmp[2];
    normpros := tmpmp[0] - LastTime(outburstchan%,tmpmp[0]);
    normproe := tmpmp[1] - LastTime(outburstchan%,tmpmp[1]);
    normre := tmpmp[2] - LastTime(outburstchan%, tmpmp[2]);
    prolat := NextTime(chan%, tmpmp[0]);  
    if (prolat>tmpmp[1]) then
        prolat := 0; 
    else prolat := prolat - tmpmp[0]; endif
    relat := NextTime(chan%, tmpmp[1]);
    if (relat>tmpmp[2]) then
        relat := 0; 
    else relat := relat - tmpmp[1]; endif
    numpspks% := ChanData(chan%,pspksarry[],tmpmp[0],tmpmp[1]);
    numrspks% := ChanData(chan%,rspksarry[],tmpmp[1],tmpmp[2]);
    divnumpsks := numpspks%; divnumrspks := numrspks%;
    proavg := divnumpsks / (absproend-absprostart);
    reavg := divnumrspks / (absreend-absproend);
    if(numpspks%) then 
        resize pspksarry[numpspks%]; 
        ArrSub(pspksarry[],tmpmp[0]);
       
    endif
    if(numrspks%) then 
        resize rspksarry[numrspks%]; 
        ArrSub(rspksarry[],tmpmp[0]);
    endif
    View(vh%);
    Print("%.4f,",absprostart);
    Print("%.4f,",absproend);
    Print("%.4f,",absreend);
    Print("%.4f,",proavg);
    if (prolat<0.0001) then
        Print(",");
    else
        Print("%.4f,",prolat);
    endif
    Print("%.4f,",reavg);
    if (relat<0.0001) then
        Print(",");
    else
        Print("%.4f,",relat);
    endif
    Print("%g%%,",numpspks%);
    if(numpspks%) then 
        Print("%.4f,",pspksarry);
    else 
        Print(",");
    endif
    Print("%g%%,",numrspks%);
    if(numrspks%) then 
        Print("%.4f,",rspksarry);
    else 
        Print(",");
    endif
    Print("\n");
    View(viewtemp%);
end

    

