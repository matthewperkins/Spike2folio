'to count spikes for cells with big platow potentials, it may work well to create a mem channel
'with a slope calculation, and then count events off this channel, this will neccisate counting 
'times on the slope channel, and then finding the voltage at that time on the real channel.
'to accurately find the peak voltage, use time of the zero crossing folloing the peak in the slope channel.
'the array that holds the spike times should hold only this zero crossing time.

var enstimchan%, enstimtimes, enstimVs1, i2, bn2, rn;
var howmanychan, whichchan[10];
var motorprograms[100][15];
'start end iprgi istrti tot_dur pro_dur re_dur chan1proavgF chan1reavgF ... to nchan
var nrvstim[2000];                                              'use to hold nerve stim times
var startt, endt;                                               'for designating the portion of time to run over.
var chanlist%[20];
var ishandmarked%, protractstart%, protractend%, profeaturechan%, refeaturechan%;
var isretracthandmarked%, retractstart%, retractend%;
var ishalrunning%;
var probursts%, prostarts%, proends%, reends%;
var prostartcurs%, proendcurs%, reendcurs%;
var i2chan%, i2evnts%, bn2chan%, bn2evnts%;
var k%;

    

'HANDLE VIEWS
var viewtemp%;
viewtemp% := View(0);  'Save the current view
View(viewtemp%);         'restore the original view
DrawAll();
FrontView(viewtemp%);
ChanList(chanlist%, 0x800);

'DELIMIT REGION, interact to place cursors bounding the region want to analyse.
CursorDelete(-1);           'Delete all cursors.
CursorNew();                'Create new cursor in middle of view.
CursorNew();                'Create new cursor in middle of view.
Interact("DRAG THE TWO CURSORS TO DELIMIT YOUR TIME????? THEN PRESS THE TINY OKAY BUTTON!!!!!", 2);
    startt := Cursor(1);
endt := Cursor(2);
enstimchan%:= Input("What channel\n is enstim command volt?\n Give ZERO for no command volt", 11);

'SELECT WHICH CASE TO PERFORM
var caseslct%;
caseslct% := Input("Enter (1) - handmark mps?", 1);
docase
    case(caseslct%=1) then
    profeaturechan% := Input("Chan for PROTRACTION features",8);
    refeaturechan% := Input("Chan for RETRACTION features",9);
    ChanHide(-1);
    ChanShow(profeaturechan%, refeaturechan%);
    Draw(startt,40);
    prostarts% := MemChan(2); proends% := MemChan(2); reends% := MemChan(2);
    ChanShow(prostarts%,proends%,reends%);
    CursorDelete(-1);
    prostartcurs% := CursorNew(); proendcurs% := CursorNew(); reendcurs% := CursorNew();
    CursorLabel(4, prostartcurs%,"prostartcur"); CursorLabel(4,proendcurs%,"proendcur");
    CursorLabel(4, reendcurs%,"reendcur");
    CursorLabelPos(prostartcurs%,50); CursorLabelPos(proendcurs%,50); CursorLabelPos(reendcurs%,50);
    
    ToolbarClear();
    ToolbarSet(9,"&f frwd||jump forward one view width", forwarddraw%);
    ToolbarSet(8,"&r rvsr||jump backward one view width", backwarddraw%);
    ToolBarSet(7,"&e addpS||Add a protraction start at Cursor", addprostart%);
    ToolBarSet(6,"&u addpE||Add a pro END at Cursor", addproend%);
    ToolBarSet(5,"&i delpS||Delete last prostart before prostart cursor", delprostart%);
    ToolBarSet(4,"&d delpE||Delete the pro end before proend cursor", delproend%);
    ToolBarSet(3,"&j addrE||Add a RETRACT END at Cursor", addreend%);
    ToolBarSet(2,"&k delrE||Delete last RETRACT END before reend cursor", delreend%);
    ToolBarSet(1,"&l save||save eventchannels and leave",outie%);
    ToolbarEnable(1,1);
    Toolbar("",1);
    prostarts% := ChanSave(prostarts%,0);
    proends% := ChanSave(proends%,0);
    reends% := ChanSave(reends%,0);
    
    case(caseslct%=2) then
    refeaturechan% := Input("Chan for RETRACTION features",9);
    ChanHide(-1);
    ChanShow(refeaturechan%);
    Draw(startt,40);
    reends% := MemChan(2);
    ChanShow(reends%);
    CursorDelete(-1);
    reendcurs% := CursorNew();
    CursorLabel(4, reendcurs%,"reendcur");
    ToolbarClear();
    ToolbarSet(5,"&F frwd||jump forward one view width", forwarddraw%);
    ToolbarSet(4,"&R rvsr||jump backward one view width", backwarddraw%);
    ToolBarSet(3,"&J addrE||Add a RETRACT END at Cursor", addreend%);
    ToolBarSet(2,"&K delrE||Delete last RETRACT END before reend cursor", delreend%);
    ToolBarSet(1,"&L save||save eventchannels and leave",outie2%);
    ToolbarEnable(1,1);
    Toolbar("",1);
    i2chan%:= Input("What channel\n is i2nerve?", 1);
    i2evnts% := motornerveburst(i2chan%,enstimchan%);
    prostarts% := i2burststart(i2evnts%);
    proends% := i2burstend(i2evnts%);
    prostarts% := ChanSave(prostarts%,0);
    proends% := ChanSave(proends%,0);
    reends% := ChanSave(reends%,0);

    case(caseslct%=3) then
    i2chan%:= Input("What channel\n is i2nerve?", 8);
    bn2chan%:= Input("What channel\n is buccal nerve 2?", 5);
    i2evnts% := motornerveburst(i2chan%,enstimchan%);
    prostarts% := i2burststart(i2evnts%);
    proends% := i2burstend(i2evnts%);
    probursts% := i2burst(i2evnts%);
    probursts% := ChanSave(probursts%,0);
    prostarts% := ChanSave(prostarts%,0);
    proends% := ChanSave(proends%,0);
    bn2evnts% := motornerveburst(bn2chan%,enstimchan%);
endcase

'protractstart% := Input("Which chan is\n protraction start marks?",0);
'protractend% := Input("Which chan is\n ... END marks?",0);
'for filling arry with Motor Program Metrics    

proc getformmarks(outmps[][], pstartmarkchan%, pendmarkchan%, rstartmarkchan%, rendmarkchan%)
    var j%,pstarttmp, pendtmp, rstarttmp, rendtmp;
    for j% := 0 to MemGetItem(pstartmarkchan%,0) do
        pstarttmp := MemgetItem(pstartmarkchan%,j%);
        pendtmp := NextTime(pendmarkchan%,MemGetItem(pstartmarkchan%,j%));
        rstarttmp := NextTime(rstartmarkchan%,MemGetItem(pstartmarkchan%,j%));
        rendtmp := NextTime(rendmarkchan%,MemGetItem(pstartmarkchan%,j%));
        outmps[j%][0] := pstarttmp;
        outmps[j%][1] := rendtmp;
        if (j%>0) then outmps[j%][2] := LastTime(rendmarkchan%,pstarttmp) - pstarttmp; endif 'interprogintv
        if (j%>0) then outmps[j%][3] := LastTime(pstartmarkchan%,pstarttmp) - pstarttmp; endif'interstartintv
        outmps[j%][4] := rendtmp - pstarttmp; 'tot_dur
        outmps[j%][5] := pendtmp - pstarttmp; 'pro_dur
        outmps[j%][6] := rendtmp - rstarttmp; 're_dur
    next
end

'FOR EACH CHAN make slope mem chan, count events, 
func i2burst(i2evntchan%)
    var i2burstchan%, j%;
    i2burstchan% := MemChan(2);
    BurstMake(i2burstchan%,i2evntchan%,startt,endt,0.8,0.8,10);
    return i2burstchan%;
end

func i2burststart(i2evntchan%)
    var i2burstchan%, j%, i2starts%;
    i2burstchan% := MemChan(2);
    i2starts% := MemChan(2);
    BurstMake(i2burstchan%,i2evntchan%,startt,endt,0.8,0.8,10);
    for j% := 1 to MemGetItem(i2burstchan%,0) step 2 do
        MemSetItem(i2starts%,0,MemGetItem(i2burstchan%,j%));
    next
    return i2starts%;
end

func i2burstend(i2evntchan%)
    var i2burstchan%, j%, i2ends%;
    i2burstchan% := MemChan(2);
    i2ends% := MemChan(2);
    BurstMake(i2burstchan%,i2evntchan%,startt,endt,0.8,0.8,10);
    for j% := 0 to MemGetItem(i2burstchan%,0) step 2 do
        MemSetItem(i2ends%,0,MemGetItem(i2burstchan%,j%));
    next
    return i2ends%;
end


func mnburstend()
end

func motornerveburst(mnchan%,stimchan%)
    var mnspks%, stimulustmp%;
    stimulustmp% := findstimulus(stimchan%);
    mnspks% := findspks(mnchan%);
    mnspks% := tossperistimgarbage(mnchan%,mnspks%,stimulustmp%);
    return mnspks%;
end

func findstimulus(n%)
    var stimevent%, enthresh;
    var append$ := "EVNT";
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, startt, endt, 3, 0, enthresh);
    setchantitle(n%, stimevent%, append$);
    return stimevent%
end

func findsixsigma(n%)
    var mean, sdd, thresh;
    mean := ChanMeasure(n%,2,startt,endt);
    sdd  := ChanMeasure(n%,12,startt,endt);
    thresh := mean + (6*sdd);
    return thresh;
end

func findspks(n%)
    var slopchantmp%, eventchantmp%, tmpthresh, plotrangtmp;
    var append$ := "_pk";
    slopchantmp% := MemChan(0,n%);
    MemImport(slopchantmp%, n%, startt, endt);
    ChanProcessAdd((slopchantmp%),3,0.0006); 'add a slope channel process 3, time contant for slope calculation is sampling interval about.  
    ChanHide(-1); ChanShow(n%); ChanShow(slopchantmp%);
    plotrangtmp := findsixsigma(slopchantmp%);
    YRange(slopchantmp%,-plotrangtmp,plotrangtmp);
    Draw(startt,endt-startt);
    HCursorDelete(-1);
    HCursorNew(slopchantmp%); HCursorNew(slopchantmp%);
    Interact("move cursors",2);
    HCursorRenumber();
    tmpthresh := HCursor(2) - HCursor(1);
    eventchantmp% := MemChan(2);
    MemImport(eventchantmp%, slopchantmp%, startt, endt, 0, 0.0001, tmpthresh);
    setchantitle(n%, eventchantmp%, append$);
    return eventchantmp%;
end

func tossperistimgarbage(nchan%,nspks%,stims%)
    var j%, prepad, postpad;
    ChanHide(-1); ChanShow(nchan%,nspks%,stims%);
    Draw(MemGetItem(stims%,2)-0.5,1);
    CursorDelete(-1);
    CursorNew(); CursorNew();
    Interact("please place cursors to straddle garbage events around ONE stim pulse",2);
    CursorRenumber();
    prepad := NextTime(stims%,Cursor(1))-Cursor(1);
    postpad := Cursor(2) - LastTime(stims%,Cursor(2));
    for j% := 0 to MemGetItem(stims%,0) do
        MemDeleteTime(nspks%, 3, (MemGetItem(stims%,j%)-prepad), (MemGetItem(stims%,j%)+postpad));
    next
    return nspks%;
end

proc setchantitle(inchan%, outchan%, appendstring$)
    var tmpchantit$;
    tmpchantit$ := ChanTitle$(inchan%);
    tmpchantit$ := Print$("%s_%s",Left$(tmpchantit$,5),appendstring$);
    ChanTitle$(outchan%,tmpchantit$);
end

'TOOLBAR FUNCTION FOR ADDING & RMVING PRO STARTS, ENDS AND RETR ENDS
func forwarddraw%()
var ttmp, rngtmp;
    rngtmp := XHigh()-XLow();
    ttmp := XLow() + rngtmp*0.75;
    Cursor(prostartcurs%,(ttmp+rngtmp*0.2));Cursor(proendcurs%,(ttmp+rngtmp*0.4));Cursor(reendcurs%,(ttmp+rngtmp*0.6));
    Draw(ttmp);
return(1);
end

func backwarddraw%()
var ttmp, rngtmp;
    rngtmp := XHigh()-XLow();
    ttmp := XLow() - rngtmp*0.75;
    Cursor(prostartcurs%,(ttmp+rngtmp*0.2));Cursor(proendcurs%,(ttmp+rngtmp*0.4));Cursor(reendcurs%,(ttmp+rngtmp*0.6));
    Draw(ttmp);
return(1);
end

func addprostart%()
    var cur1;
    cur1 := Cursor(prostartcurs%);
    MemSetItem(prostarts%,0,cur1);
    Draw();
    return(1);
end

func addproend%()
    var cur1;
    cur1 := Cursor(proendcurs%);
    MemSetItem(proends%,0,cur1);
    Draw();
return(1);
end

func delprostart%()
    var cur1; var numitems%;
    cur1 := Cursor(prostartcurs%);
    numitems% := MemGetItem(prostarts%);
    MemDeleteItem(prostarts%,numitems%);
    Draw();
return(1);
end

func delproend%()
    var cur1; var numitems%;
    cur1 := Cursor(proendcurs%);
    numitems% := MemGetItem(proends%);
    MemDeleteItem(proends%,numitems%);
    Draw();
return(1);
end

func addreend%()
    var cur1;
    cur1 := Cursor(reendcurs%);
    MemSetItem(reends%,0,cur1);
    Draw();
return(1);
end
 
func delreend%()
    var cur1; var numitems%;
    cur1 := Cursor(reendcurs%);
    numitems% := MemGetItem(reends%);
    MemDeleteItem(reends%,numitems%);
    Draw();
return(1);
end

func outie%()
    ChanTitle$(prostarts%,"prostarts"); ChanTitle$(proends%,"proends"); ChanTitle$(reends%,"reends");
    ChanSave(prostarts%,-1); ChanSave(proends%,-1); ChanSave(reends%,-1);
return(0);
end

func outie2%()
    ChanTitle$(reends%,"reends");
    ChanSave(reends%,-1);
return(0);
end


