'to remove an average stimulus artifact for neurogram channels, and possibly cell channels.
'need a stimulus marker channel.
'assumes the sample rate is 5000Hz

var i2chan%, bn2chan%, rnchan%, stimchan%, stims[5000], avgdart[50000], startt, endt;
var stimtimeadvance, tlen%;
var smplrate;
var howmany%;

'HANDLE VIEWS
var viewtemp%;
viewtemp% := View(0);  'Save the current view
View(viewtemp%);         'restore the original view
DrawAll();
FrontView(viewtemp%);


CursorDelete(-1);
CursorNew();CursorNew();

Interact("DRAG THE TWO CURSORS TO DELIMIT YOUR TIME????? THEN PRESS THE TINY OKAY BUTTON!!!!!", 2);
startt := Cursor(1);
endt := Cursor(2);
howmany% := Input("How many channels?",3);

'AUTOMATTICALLY FIND STIMULUS ONSETT AND OFFSET
var stimeventstart%, stimeventend%;
stimchan% := Input("What channel\n is enstim command volt?", 7);
stimeventstart% := findstimulusstart(stimchan%);
stimeventend% := findstimulusend(stimchan%);

'FIND AVERAGE ISI, TO INDEX ARRAYS WITH
var avgisi, dpavgisi%, dpstimart%, timstimart, avgstimdur, minisi, minisidp%;
smplrate := Input("what is the sample rate (Hz)", 2000); 
stims[0] := ChanData(stimeventstart%, stims[1:4999],startt, endt);
avgisi := findavgisi(stimeventstart%);
minisi := findminisi(stimeventstart%);
avgstimdur := findavgstmdur(stimeventstart%,stimeventend%);
dpavgisi% := floor(avgisi*smplrate);
dpstimart% := Ceil(dpavgisi%*0.99);
timstimart := (dpavgisi%*0.99/smplrate);

'SET PADDINGS
var leftpadmillisec, prepad, postpad, cellavgdurprcnt;
prepad := 3; 
postpad := 3;
leftpadmillisec := 10;
cellavgdurprcnt := 0.1; 'as percent (of avg stim isi)
cellavgdurprcnt := cellavgdurprcnt*avgisi;  'percnts now seconds

'FIND THE AVERAGE PERI STIMULUS WAVE FORM, SET LEFT PAD
var j%, outchan%, whichchan%, iscell%;
whichchan% := 0;
for j% := 1 to howmany% do
    whichchan% := Input("whichchan?", whichchan%+j%);
    iscell% := Input("is this channel a cell?", 1);
    findavgstimart(whichchan%,avgdart[],leftpadmillisec,dpstimart%,timstimart);
    tlen% := avgdart[0];
    PrintLog(avgdart[1:tlen%]);
    outchan% := substract(whichchan%,avgdart[1:tlen%],leftpadmillisec,dpstimart%,timstimart, iscell%, cellavgdurprcnt);
    zeroout(outchan%,prepad,postpad,avgstimdur,iscell%, cellavgdurprcnt, avgisi);
next

'FUNCTIONS ARE DEFINED BELOW:
func substract(chan%,avgstimart[], prepadmillisec, dplength%,timart, iscll%, cellavgdur) 'give the time over which to avg the cell mem as prcnt(of avgisi)
    var dupchan%;
    dupchan% := MemChan(0,chan%);
    MemImport(dupchan%,chan%,0,MaxTime(chan%));

    var i%, count%;
    var tmp[dplength%], prestimavg, thistmplength%, avgrmp := 0;
    count% := 0;
    for i% := 1 to stims[0]-1 do
    thistmplength% := ChanData(chan%,tmp[],stims[i%],stims[i%+1]);
'    if (iscll%) then
'       avgrmp := ChanMeasure(chan%,2,stims[i%+1]-cellavgdur, stims[i%+1]);
'    endif;
    ArrSub(tmp[],avgstimart[]);
    ArrSub(tmp[],avgrmp);
    ChanWriteWave(dupchan%,tmp[],stims[i%]-(prepadmillisec/1000));
    next;
    return dupchan%
end

proc zeroout(chan%, prestartmilli, postendmilli, avgdur, iscll%, cellavgdur, avgisi); 'avgisi is time not data points
    var i%, ontmp, prelen%, postlen%, avgrmp;
    prelen% := Ceil((prestartmilli/1000)*smplrate);
    postlen% := Ceil((avgdur*smplrate)+(postendmilli/1000)*smplrate);
    var prearr[prelen%], postarr[postlen%];
    for i% := 1 to stims[0]-1 do
    ontmp := MemGetItem(stimeventstart%, i%);
'        if (iscell%) then
'            avgrmp:= ChanMeasure(chan%,1, ontmp-(prestartmilli/1000)-(avgisi*cellavgdur),ontmp-(prestartmilli/1000));
'            ArrConst(prearr[],avgrmp);
'            ArrConst(postarr[],avgrmp);
'        endif;
        ChanWriteWave(chan%, prearr[], ontmp-(prestartmilli/1000));
        ChanWriteWave(chan%, postarr[], ontmp-0.001);
    next
end

func findavgstmdur(stimon%, stimoff%);
    var i%, numevents%, midstart%, midlen%, avgdur;
    numevents% := stims[0];
    var stimson[numevents%], stimsoff[numevents%];
    ChanData(stimon%,stimson[],startt,endt);
    ChanData(stimoff%,stimsoff[],startt,endt);
    midstart% := floor(numevents%*0.2);
    midlen% := floor(numevents%- (numevents%*0.4));
    var midarray[midlen%];
    ArrAdd(midarray[],stimsoff[midstart% : midlen%]);
    ArrSub(midarray[],stimson[midstart% : midlen%]);
    ArrSum(midarray[], avgdur);
    Return avgdur;
end
    
func findstimulusstart(n%)
    var stimevent%, enthresh;
    var append$ := "sVNT";
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, startt, endt, 2, 0, enthresh);
    setchantitle(n%, stimevent%, append$);
    return stimevent%
end

func findstimulusend(n%)
    var stimevent%, enthresh;
    var append$ := "eVNT";
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, startt, endt, 3, 0, enthresh);
    setchantitle(n%, stimevent%, append$);
    return stimevent%
end


func findavgisi(evntstimchan%)
    var i%, favgisi, numevents%, midstart%, midlen%;
    numevents% := stims[0];
    midstart% := floor(numevents%*0.2);
    midlen% := floor(numevents%- (numevents%*0.4));
    var midarray[midlen%];
    ArrAdd(midarray,stims[midstart% : midlen%]);
    ArrDiff(midarray[]);
    ArrSum(midarray[1:midlen%-1], favgisi);
    Return favgisi;
end

func findminisi(evntstimchan%)
    var i%, minisi, numevnts%;
    numevnts% := stims[0];
    var events[numevnts%];
    ArrAdd(events[],stims[1 : numevnts%]);
    ArrDiff(events[]);
    Min(events[]);
    Return minisi;
end
            
func findavgstimart(chan%,avgart[],prepadmillisec, dplength%, timart)    
    ArrMul(avgart[],0);
    var i%, count%;
    var tmp[dplength%], sumtmp[dplength%];
    count% := 0;
    for i% := 1 to stims[0]-1 do
        ChanData(chan%,tmp[],stims[i%]-(prepadmillisec/1000),stims[i%]+timart);
        ArrAdd(sumtmp[],tmp[]);
        count% := count% + 1;
    next;
    ArrDiv(sumtmp, count%);
    avgart[0] := dplength%;
    ArrAdd(avgart[1:],sumtmp[]);
end

func findsixsigma(n%)
    var mean, sdd, thresh;
    mean := ChanMeasure(n%,2,startt,endt);
    sdd  := ChanMeasure(n%,12,startt,endt);
    thresh := mean + (6*sdd);
    return thresh;
end

proc setchantitle(inchan%, outchan%, appendstring$)
    var tmpchantit$;
    tmpchantit$ := ChanTitle$(inchan%);
    tmpchantit$ := Print$("%s_%s",Left$(tmpchantit$,5),appendstring$);
    ChanTitle$(outchan%,tmpchantit$);
end
