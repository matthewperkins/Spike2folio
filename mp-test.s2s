'to count spikes for cells with big platow potentials, it may work well to create a mem channel
'with a slope calculation, and then count events off this channel, this will neccisate counting 
'times on the slope channel, and then finding the voltage at that time on the real channel.
'to accurately find the peak voltage, use time of the zero crossing folloing the peak in the slope channel.
'the array that holds the spike times should hold only this zero crossing time.

var enstimchan, enstimtimes, enstimVs1, i2, bn2, rn;
var howmanychan, whichchan[10];
var pip1[2000],    pip2[2000],    pip3[2000],    pip4[2000];    'use to hold spiketimes
var pip1sV[2000],  pip2sV[2000],  pip3sV[2000],  pip4sV[2000];  'use to hold spikevoltages
var pip1rmp[2000], pip2rmp[2000], pip3rmp[2000], pip4rmp[2000]; 'use to hold rmps
var nrvstim[2000];                                              'use to hold nerve stim times
var stimpostpadgram;                                            'set post stimulus time to drop for neurograms
var stimpostpadpip;                                             'set post stimulus time to drop for sharp pipettes
var piprmppre;
var startt, endt;                                               'for designating the portion of time to run over.
var chanlist%[20];

'SET CONTANSTS
piprmppre:= 0.2; 'time before current pulse that starts rmp average

'HANDLE VIEWS
var viewtemp%;
viewtemp% := View(0);  'Save the current view
View(viewtemp%);         'restore the original view
DrawAll();
FrontView(viewtemp%);
ChanList(chanlist%, 0x800);


'DELIMIT REGION, interact to place cursors bounding the region want to analyse.
CursorDelete(-1);           'Delete all cursors.
CursorNew();                'Create new cursor in middle of view.
CursorNew();                'Create new cursor in middle of view.
Interact("DRAG THE TWO CURSORS TO DELIMIT YOUR TIME????? THEN PRESS THE TINY OKAY BUTTON!!!!!", 2);
startt := Cursor(1);
endt := Cursor(2);
enstimchan:= Input("What channel\n is enstim command volt?", 4);

var i2evnts%;
i2evnts% := protractretract();

'FOR EACH CHAN make slope mem chan, count events, 
func protractretract()
    var i2chan%, bn2chan%, stimulustmp%, prepad, postpad, thresh, i2spks%, bn2spks%,j%;
    i2chan%:= Input("What channel\n is i2nerve?", 1);
    bn2chan%:= Input("What channel\n is buccal nerve 2?", 2);
    stimulustmp% := findstimulus(enstimchan);
    i2spks% := findspks(i2chan%);
    ChanHide(-1); ChanShow(i2spks%,i2chan%,stimulustmp%);
    CursorDelete(-1);
    CursorNew(); CursorNew();
    Interact("please place cursors to straddle garbage events around ONE stim pulse",2);
    CursorRenumber();
    prepad := NextTime(stimulustmp%,Cursor(1))-Cursor(1);
    postpad := Cursor(2) - LastTime(stimulustmp%,Cursor(2));
    for j% := 0 to MemGetItem(stimulustmp%,0) do
        MemDeleteTime(i2spks%, 3, (MemGetItem(stimulustmp%,j%)-prepad), (MemGetItem(stimulustmp%,j%)+postpad));
    next
    return i2spks%;
end

    

func findstimulus(n%)
    var stimevent%, enthresh;
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, startt, endt, 3, 0, enthresh);
    return stimevent%
end

func findsixsigma(n%)
    var mean, sdd, thresh;
    mean := ChanMeasure(n%,2,startt,endt);
    sdd  := ChanMeasure(n%,12,startt,endt);
    thresh := mean + (6*sdd);
    return thresh;
end

func findspks(n%)
    var slopchantmp%, eventchantmp%, tmpthresh;
    slopchantmp% := MemChan(0,n%);
    MemImport(slopchantmp%, n%, startt, endt);
    ChanProcessAdd((slopchantmp%),3,0.0006); 'add a slope channel process 3, time contant for slope calculation is sampling interval about.  
    HCursorDelete(-1);
    HCursorNew(slopchantmp%); HCursorNew(slopchantmp%);
    ChanHide(-1); ChanShow(n%); ChanShow(slopchantmp%);
    Interact("move cursors",2);
    HCursorRenumber();
    tmpthresh := HCursor(2) - HCursor(1);
    eventchantmp% := MemChan(2);
    MemImport(eventchantmp%, slopchantmp%, startt, endt, 0, 0.0001, tmpthresh);
    return eventchantmp%;
end   