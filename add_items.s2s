'to count spikes for cells with big platow potentials, it may work well to create a mem channel
'with a slope calculation, and then count events off this channel, this will neccisate counting 
'times on the slope channel, and then finding the voltage at that time on the real channel.
'to accurately find the peak voltage, use time of the zero crossing folloing the peak in the slope channel.
'the array that holds the spike times should hold only this zero crossing time.

#include <C:\Documents and Settings\matthew\Documents\weiss_lab\Spike2folio\basic_view.s2s>     'this will bring in two globals: GVt% and GGChanList%[]

var MarkFeature%, features%[10], FeatureCurs%;

'SELECT OTHER CHANNELS FOR VISUAL GUIDENCE
Interact("Select chans to see while messing around", 1023, 0, "&O Okay");
ChanList(features%[],65536);
ChanHide(-1);
ChanShow(features%[]);

'MAKE THE MARKFEATURE CHANNEL AND SHOW IT
MarkFeature% := MemChan(2);
ChanShow(MarkFeature%);
Draw(0,40);

'PUT LABELED CURSORS IN VIEW
CursorDelete(-1);
FeatureCurs% := CursorNew();
CursorLabel(4, FeatureCurs%,"Feature Cursor"); 
CursorLabelPos(FeatureCurs%,50);

ToolbarClear();
ToolbarSet(9,"&f frwd||jump forward one view width", forwarddraw%);
ToolbarSet(8,"&r rvsr||jump backward one view width", backwarddraw%);
ToolBarSet(7,"&e addpS||Add a Feature Item at Cursor", addfeature%);
ToolBarSet(5,"&i delpS||Delete last Feature Item before Feature Cursor", delfeature%);
ToolBarSet(1,"&l save||save eventchannels and leave",outie%);
ToolbarEnable(1,1);
Toolbar("",1);

ChanSave(MarkFeature%,0);
    
'TOOLBAR FUNCTION FOR ADDING & RMVING PRO STARTS, ENDS AND RETR ENDS
func forwarddraw%()
var ttmp, rngtmp;
    rngtmp := XHigh()-XLow();
    ttmp := XLow() + rngtmp*0.1;
    Cursor(FeatureCurs%,(ttmp+rngtmp*0.4));
    Draw(ttmp);
return(1);
end

func backwarddraw%()
var ttmp, rngtmp;
    rngtmp := XHigh()-XLow();
    ttmp := XLow() - rngtmp*0.1;
    Cursor(FeatureCurs%,(ttmp+rngtmp*0.4));
    Draw(ttmp);
return(1);
end

func addfeature%()
    var cur1;
    cur1 := Cursor(FeatureCurs%);
    MemSetItem(MarkFeature%,0,cur1);
    Draw();
    return(1);
end

func delfeature%()
    var cur1; var numitems%;
    cur1 := Cursor(FeatureCurs%);
    numitems% := MemGetItem(MarkFeature%);
    MemDeleteItem(MarkFeature%,numitems%);
    Draw();
return(1);
end

func outie%()
    ChanTitle$(MarkFeature%,"marked_feature"); 
    ChanSave(MarkFeature%,-1);
return(0);
end


