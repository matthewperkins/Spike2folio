'protraction channel
'retraction channel
'first select protractions and retraction channels
'SELECT i2 burst channel 
#include "include\basic_view.s2s"     'this will bring in two globals: GVt% and GChanList%[]
#include "include\AbfStartTime.s2s"    'bring in proc AbfStartTime(vh%, FileTimeVect%[7]), has python script dependency "get_abf_start.py", and Win send .py to python.exe
#include "include\PrintHeaderStim.s2s" 'bring in PrintHeaderStim(EvntChn%, MrkChan%, delim$), where EvntChn and MrkChn are En Stim or Cbi2 stim

var protraction%;
var SnglSlctChn%[2];

'SELECT protraction
Interact("Select protraction 00 01 (burst) channel", 65536, 0, "&O Okay");
ChanList(SnglSlctChn%, 65536);
protraction%:= SnglSlctChn%[1];

'SELECT a retraction channel
var retraction%;
Interact("Select retraction 00 01 (burst) channel", 65536, 0, "&O Okay");
ChanList(SnglSlctChn%, 65536);
retraction%:= SnglSlctChn%[1];

'SELECT a trig stim
var stimulustrigger%;
Interact("Select stimulus 00 01 (burst) channel", 65536, 0, "&O Okay");
ChanList(SnglSlctChn%, 65536);
stimulustrigger%:= SnglSlctChn%[1];

'Select any ON Off condition channels 
var CondChns%[10];
var NumCondChans%;
Interact("select and On Off Condition channels", 65536, 0, "&O Okay");
ChanList(CondChns%[], 65536);
NumCondChans% := CondChns%[0];

'SELECT a measurement channels
var MultSlctChn%[10];
var NumMsrChans%;
Interact("select all your measurement channels", 65536, 0, "&O Okay");
ChanList(MultSlctChn%[],65536);
NumMsrChans% := MultSlctChn%[0];
resize MultSlctChn%[NumMsrChans%+1];

'''FILE NAMES PREP, and FILE INF PREP'''
    var GFName$, GDirString$, GFullFName$;
    var GFileTimeVec%[7];
    var NumHeaders%;
    GFullFName$ := FileName$();
    GFName$ := Print$("%s%s",FileName$(3),FileName$(4));
    GDirString$ := Print$("%s\%s",FileName$(2),"..\\indiv_cells\\");
    AbfStartTime(GVt%, GFileTimeVec%[]);

    'CREATE measurement views/files
    NumHeaders% := ClcNumHdrLns(CondChns%[],7);
    var MsrmntViews%[10];
    var j%;
    var GDelim$ := ",";
    resize MsrmntViews%[NumMsrChans%+1];
    PrepHeadersTop(MultSlctChn%[], MsrmntViews%[], NumHeaders%, GFName$);
    PrepHeaderStim(CondChns%[], MsrmntViews%[], GDelim$);
    PrepHeaderBtm(MsrmntViews%[]);
'''END FILE NAMES PREP'''

'use marker code 0 0 0 0 for burst start
var startcode%[4];
ArrConst(startcode%[], 0);

'use marker code 1 0 0 0 for burst END
var endcode%[4];
ArrConst(endcode%[], 0);
endcode%[0] := 1;

'loop over protraction starts
var NumProStarts%;
var i%;
var prostart := 0;
var proend := 0;
var restart := 0;
var reend :=0;

NumProStarts%:= Count(protraction%,0,MaxTime()) / 2 ;

for i% :=1 to NumProStarts% do
    prostart := GetNextExctCode(protraction%, prostart, startcode%[]);
    proend := GetNextExctCode(protraction%, prostart, endcode%[]);
    restart := GetNextExctCode(retraction%, prostart, startcode%[]);
    reend := GetNextExctCode(retraction%, restart, endcode%[]);
    docase
        case ((restart - proend) < 0.7) then
            'case solo protraction
            RecordMotorProgram(MultSlctChn%[], MsrmntViews%[], stimulustrigger%, prostart, proend, restart, reend);
        case ((restart - proend) >= 0.7) then
            'case full motor program
    endcase;        
next;

SvCls(MultSlctChn%[], MsrmntViews%[]);

'SAVE AND CLOSE FILES
proc SvCls(Chans%[], Views%[]);
    var j%, ChnNm$;
    for j% := 1 to Views%[0] do
        View(GVt%);
        ChnNm$ := ChanTitle$(Chans%[j%]);
        ChnNm$:= Print$("%s_%s.csv", GFName$, ChnNm$);
        View(Views%[j%]);
        FilePathSet(GDirString$); FileSaveAs(ChnNm$,1); FileClose();
    next;
end

'PROCS AND FUNCTIONS 
proc PrepHeadersTop(Chans%[], Views%[], NmHdrs%, GFName$)
    var i%;
    var ChnNm$;
    for i% := 1 to Chans%[0] do
        FrontView(GVt%);
        ChnNm$ := ChanTitle$(Chans%[i%]);
        Views%[i%] := FileNew(1);
        Views%[0] := Views%[0] + 1;
        Print("num_headers,%g,\n", NmHdrs%);
        Print("file_name,%s,\n",GFName$);
        Print("cell_name,%s,\n",ChnNm$);
        Print("%s\n", "file_start_time");
        Print("%s,", "year");
        Print("%s,", "month");
        Print("%s,", "day");
        Print("%s,", "hour");
        Print("%s,", "minute");
        Print("%s,", "second");
        Print("%s,\n", "microsecond");
        Print("%g", GFileTimeVec%[]);
        Print("\n");
       
    next;
    FrontView(GVt%);
end

proc PrepHeaderBtm(Views%[])
    var i%;
    for i% := 1 to Views%[0] do
        View(Views%[i%]);
        Print("pro_latency,");
        Print("abs_pro_start,");
        Print("pro_start,");
        Print("pro_end,");
        Print("re_end,");
        Print("avg_freq_p,");
        Print("laten_p,");
        Print("num_spk_p,");
        Print("avg_freq_r,");
        Print("laten_r,");
        Print("num_spk_r,");
        Print("times_spk\n");
    next;
    FrontView(GVt%)
end

proc PrepHeaderStim(CndChns%[], Views%[], Delim$)
    var condcount%, viewcount%;
    for condcount% := 1 to CndChns%[0] do
        for viewcount% := 1 to Views%[0] do
            PrintHeaderStim(CndChns%[condcount%], CndChns%[condcount%], GVt%, Views%[viewcount%], Delim$);
        next;
    next;
end

func GetNextExctCode(chan%, time, code%[])
    var nextcode%[4];
    var codematch% := 1; 'codematch will be zero when match found
    while (codematch%=1) do
        time := NextTime(chan%,time,nextcode%);
        ArrSub(nextcode%[], code%[]);
        codematch% := ArrSum(nextcode%[]);
        if (time=-1) then break endif;
    wend;
    return time;
end;

func GetLastExctCode(chan%, time, code%[])
    var nextcode%[4];
    var codematch% := 1; 'codematch will be zero when match found
    while (codematch%=1) do
        time := LastTime(chan%,time,nextcode%);
        ArrSub(nextcode%[], code%[]);
        codematch% := ArrSum(nextcode%[]);
        if (time=-1) then break endif;
    wend;
    return time;
end;        

Proc RecordMotorProgram(MultSlctChn%[], MsrmntViews%[], trigchan%, prostart, proend, restart, reend)
    var i%;
    for i% := 1 to MultSlctChn%[0] do
        MkWrtMPMsrs(MultSlctChn%[i%], MsrmntViews%[i%], trigchan%, prostart, proend, restart, reend);
    next;
end

func ClcNumHdrLns(CondChns%[], PlsFxd%)
    var i%, LnCounter% := 0;
    for i%:=1 to CondChns%[0] do
        LnCounter% := LnCounter% + CountHeadrStimLins(CondChns%[i%]);
    next;
    return (LnCounter% + PlsFxd%);
end;

'case motor programe
'trigstim %should be a burst make output, 00 is start and 01 is end code
func MkWrtMPMsrs(chan%, vh%, trigstim%, prostart, proend, restart, reend)
    var MPprolatOn, MPprolatOff;
    var proavg, prolat, reavg, relat, pspksarry[4000], rspksarry[4000];
    var numpspks%, numrspks%;
    var divnumpsks, divnumrspks;
    MPprolatOn := GetLastExctCode(trigstim%, prostart, startcode%[]); 
    MPprolatOff := GetLastExctCode(trigstim%, prostart, endcode%[]); 
    if (MPprolatOff>MPprolatOn) then
        MPprolatOn := -1; 'this is a spontaneous program
    else MPprolatOn := prostart - MPprolatOn; endif 
    prolat := NextTime(chan%, prostart);  
    if (prolat>proend) then
        prolat := 0; 
    else prolat := prolat - prostart; endif
    relat := NextTime(chan%, restart);
    if (relat>reend) then
        relat := 0; 
    else relat := relat - restart; endif
    numpspks% := ChanData(chan%,pspksarry[],prostart,proend);
    numrspks% := ChanData(chan%,rspksarry[],restart,reend);
    divnumpsks := numpspks%; divnumrspks := numrspks%;
    proavg := divnumpsks / (proend - prostart);
    reavg := divnumrspks / (reend - restart);
    if(numpspks%) then 
        resize pspksarry[numpspks%]; 
        ArrSub(pspksarry[],prostart);
    endif
    if(numrspks%) then 
        resize rspksarry[numrspks%]; 
        ArrSub(rspksarry[],prostart);
    endif
    View(vh%);
    Print("%.4f,",MPprolatOn);
    Print("%.4f,",prostart);
    Print("%.4f,",proend);
    Print("%.4f,",restart);
    Print("%.4f,",reend);
    Print("%.4f,",proavg);
    if (prolat<0.0001) then
        Print(",");
    else
        Print("%.4f,",prolat);
    endif
    Print("%d,",numpspks%);
    Print("%.4f,",reavg);
    if (relat<0.0001) then
        Print(",");
    else
        Print("%.4f,",relat);
    endif
    Print("%d,",numrspks%);
    if(numpspks%) then 
        Print("%.4f,",pspksarry);
    else 
        Print(",");
    endif
    if(numrspks%) then 
        Print("%.4f,",rspksarry);
    else 
        Print(",");
    endif
    Print("\n");
    View(GVt%);
end  
    

