'SCRIPT TO measure inptut resistence in a two electrode experiment.
'MUST have a designated channel as a current moniter, for each cell.

var rwcnt%;
var start, iend, vt%;
var rsltsarr[20][225000], rlstmean[225000];
var thresh, seqstart, seqend, vstprmp, vstpi, vstpdelt, current;
var numspks%, spklaten, trsharry[200];
var gotonext%, isokay%;
var fname$, outresistname$, rdirstring$, outresistvh%[10],starts%[10],stops%[10],vchan%;
var stepstart, stepend;
var stpw1, stpw2, stpw3, avgover, restarttime;
var i%,j%;

'Handle Views
vt% := View(0);  'Save the current view
FrontView(vt%);
View(vt%);         'restore the original view
DrawAll();

'script consoles as of now
avgover := 0.2;
rwcnt% := 0;
isokay% := 1;
restarttime := Cursor(0); 'script starts cursor(0)
'Get File Names Ready
var howmanychans%, channame$, chanmeastmp%, chancurrenttmp%, chanspktmp%, howmanysteps%;
howmanychans% := Input("How many chans have steps?", 2);
outresistvh%[0] := howmanychans%;
starts%[0] := howmanychans%;
stops%[0] := howmanychans%;
fname$ := Print$("%s%s",FileName$(3),FileName$(4));
rdirstring$ := Print$("%s\%s",FileName$(2),fname$);

'this big ugly loop is main
for i% := 1 to howmanychans% do
    Cursor(0, restarttime);
    gotonext% := 1;
    chanmeastmp% := Input("Which Voltage chan number?", i%);
    chancurrenttmp% := Input("Which Current moniter chan number?", i%);
    channame$ := leftunblnkchan$(chanmeastmp%);
    outresistname$ := "inptrst.csv";
    outresistname$ := Print$("%s_%s_%s",fname$,channame$,outresistname$);
    howmanysteps% := Input("How many steps?",3);
    outresistvh%[i%] := FileNew(1);
    View(outresistvh%[i%]);
    for j% := 1 to howmanysteps% do 
        if (j% = 1) then
            Print("seqstart,");
            Print("seqend,");
        endif
        Print("%s_%d%s","stpstart",j%,",");
        Print("%s_%d%s","stpend",j%,",");        
        Print("%s_%d%s","vstp_rmp",j%,",");
        Print("%s_%d%s","vstp_i",j%,",");
        Print("%s_%d%s","vstp_delt",j%,",");
        Print("%s_%d%s","crnt_mntr",j%,",");
        Print("%s_%d%s","num_spks",j%,",");
        Print("%s_%d%s","fspk_lat",j%,",");
        if (j% = howmanysteps%) then
            Print("\n");
        endif
    next
    View(vt%);
    starts%[i%] := MemChan(2);
    stops%[i%] := MemChan(2);
    chanspktmp% := MemChan(2);
    MemImport(chanspktmp%, chanmeastmp%,0,MaxTime(),0,0.0001,0.025); 'the min time btwn event(6tharg) doesn't work >0.001
    vchan% := makerectslpchan(chancurrenttmp%);
    HCursorDelete(-1);
    HCursorNew(vchan%);
    ChanShow(vchan%); ChanShow(chanmeastmp%);
    Optimise(vchan%); Optimise(chanmeastmp%);
    Draw(Cursor(0),120);
    FrontView(vt%);
    Interact("Thresh",2);
    thresh := HCursor(1);
    while (gotonext%) do
        CursorDelete(-1);
        CursorActive(0, 4, vchan%, 0.01, "", "", thresh);  '8 falling thresh, 7 rising threshold
        CursorSearch(0);
        CursorVisible(0,1);
        seqstart := Cursor(0);
        CursorNew(seqstart,1);
        CursorActive(1, 4, vchan%, "Cursor(0)+0.1", "Cursor(0)+30", "Cursor(0)",  thresh);
        for j% := 1 to (howmanysteps%*2)-1 do
            CursorActive(1,4,vchan%, "Cursor(1) + 0.1", "Cursor(0) + 30", "Cursor(0)", thresh);
            CursorSearch(1);
        next
        seqend := Cursor(1);
        XRange(Cursor(0)-35,Cursor(0)+35);
        isokay% := Input("okay?|", 1);
        
        if isokay% then
            MemSetItem(starts%[i%], 0, Cursor(0));
            MemSetItem(stops%[i%], 0, Cursor(1));
                    
            docase 
                case(howmanysteps% = 1) then
                stepstart := seqstart;
                stepend := seqend;
                mkmeasurs(chanmeastmp%, chancurrenttmp%, chanspktmp%);
                printmeasurs(outresistvh%[i%],1,howmanysteps%);
                else
                    CursorActive(1, 4, vchan%, "Cursor(0)+0.1", "Cursor(0)+30", "Cursor(0)", thresh); 'start finding cursor
                    CursorActive(0, 4, vchan%, 0.1, "", "", thresh);  'end finding cursor
                    for j% := 1 to howmanysteps% do
                        docase
                            case (j%=1) then
                                stepstart := seqstart;
                                stepend := CursorSearch(1);
                                CursorSearch(0);
                                CursorSearch(0);
                            case (j%=howmanysteps%) then
                                stepstart := Cursor(0);
                                stepend := seqend;
                                CursorSearch(0);
                            else
                                stepstart := Cursor(0);
                                stepend := CursorSearch(1);
                                CursorSearch(0);
                                CursorSearch(0);
                        endcase
                        mkmeasurs(chanmeastmp%, chancurrenttmp%, chanspktmp%);
                        printmeasurs(outresistvh%[i%],j%, howmanysteps%);
                    next
            endcase;
        endif
        gotonext% := Input("next?|", 1);
        if gotonext% then
                Cursor(0,Cursor(0)+1);
        endif
    wend
    View(vt%);
    View(outresistvh%[i%]); FilePathSet(rdirstring$); FileSaveAs(outresistname$,1); FileClose();
next
ChanDelete(vchan%);
ChanDelete(starts%[]);
ChanDelete(stops%[]);
'ArrSum(rsltsarr[0:rwcnt%][], rlstmean[]);

proc mkmeasurs(chanvolts%,chancurrent%,chanspks%)
    vstprmp := ChanMeasure(chanvolts%,2,stepstart-avgover, stepstart);
    vstpi := ChanMeasure(chanmeastmp%,2,stepend-avgover, stepend);
    vstpdelt := vstpi - vstprmp;
    current := ChanMeasure(chancurrent%,2,stepend, stepstart);
    numspks% := ChanData(chanspks%, trsharry[], stepstart, stepend);
    if (numspks%) then 
        spklaten := NextTime(chanspks%, stepstart);
    else
        spklaten := -1;
    endif
    'search for spikes
end

proc printmeasurs(outvh%, i%, howmanysteps%)    
    View(outvh%);
    if (i% = 1) then
        Print("%.4f,",seqstart);
        Print("%.4f,",seqend);
    endif
    Print("%.4f,",stepstart);
    Print("%.4f,",stepend);        
    Print("%.4f,",vstprmp);
    Print("%.4f,",vstpi);
    Print("%.4f,",vstpdelt);
    Print("%.4f,",current);
    Print("%d,",numspks%);
    Print("%.4f,",spklaten);
    if (i% = howmanysteps%) then
        Print("\n");
    endif
    View(vt%);
end            

'This func deletes the mean of the current moniter channel 
'(to avoid sign problems with a holding current), then takes the 
'abs value of the of the demeaned channel so a single threshold cateches 
'both positive and negative
func makerectslpchan(chan%)
    var expr$, vchan%;
    vchan% := MemChan(0, chan%);
    MemImport(vchan%, chan%, 0.0, MaxTime()); 'Create channel copy
    ChanProcessAdd(vchan%,3,0.001);
    ChanProcessAdd(vchan%,0);
    return vchan%;
end

'This func cuts channel title: either cuts last char if it is white
'or cuts everything after(including) two contiguous whites.
func leftunblnkchan$(chan%)
    var chntit$, titlen%;
    chntit$ := ChanTitle$(chan%);
    titlen% := Len(chntit$);
    docase
        case (InStr(chntit$, " ") = (titlen%-1)) then
            chntit$ := Left$(chntit$, (titlen%-1));
        case (Instr(chntit$, "  ")) then
            titlen% := InStr(chntit$, "  ");
            chntit$ := Left$(chntit$, (titlen%-1));
    endcase
    return chntit$;
end
