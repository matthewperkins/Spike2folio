'SCRIPT TO measure inptut resistence in a two electrode experiment.
'MUST have a designated channel as a current moniter, for each cell.

'''INCLUSIONS'''
#include <basic_view.s2s>     'this will bring in two globals: GVt% and GChanList%[]
#include <basic_spk_find.s2s> 'this will bring in two globals: GChan% and GEventChan%

'''SCRIPT CONSTANTS'''
    'average the membrane potiential before the current pulse, over this many seconds
    var avgover;
    avgover := 0.2;
'''END SCRIPT CONSTANTS'''


'''FILE NAMES PREP'''
    var GFName$, GDirString$;
    GFName$ := Print$("%s%s",FileName$(3),FileName$(4));
    GDirString$ := Print$("%s\%s",FileName$(2),"..\\indiv_cells\\");
'''END FILE NAMES PREP'''



'''MAIN LOOP PREP'''
'vars for measures'
    var seqstart, seqend, vstprmp, vstpi, vstpdelt, current, fspkwdth;
    var GRMP;
    var numspks%, spklaten, trsharry[200], tau;
    
'vars for time holding in current sequence
    var SeqStartTHolder;
    var SeqEndT;
    var stepstart, stepend;

'channel vars
    var GCrrChngEvnt%, chancurrenttmp%;
    '#defined globals GChan% GEventChan%

'vars for flow cntrl 
    var gotonext%,i%,j%;
    var isokay%:=1;
    var GNumSteps%;
    var howmanychans%;

'vars for files and views
    var outresistname$, GOutResistVh%[10], channame$;
 
''''''BEGIN MAIN''''''
howmanychans% := Input("How many chans have steps?", 2);
GOutResistVh%[0] := howmanychans%;

'this big ugly loop is main
for i% := 1 to howmanychans% do
    'return the view    
    RestoreStartView();
        
    GChan% := Input("Which Voltage chan number?", i%);
    chancurrenttmp% := Input("Which Current moniter chan number?", i%);
    channame$ := leftunblnkchan$(GChan%);
    outresistname$ := "inptrst.csv";
    outresistname$ := Print$("%s_%s_%s",GFName$,channame$,outresistname$);
    GNumSteps% := Input("How many steps?",1);
    GOutResistVh%[i%] := FileNew(1);
    
    'Print the header for the measurements csv file
    View(GOutResistVh%[i%]).PrntHeader(GNumSteps%);
    
    'return the view    
    RestoreStartView();
    
    'get the spikes from the channel as events    
    GEventChan% := FindSpks(GChan%);
    GRMP := FindRMP(GChan%);
    
    'add created event channel to GChanList (displayed with RestoreStartView)
    AddChanToStartView(GEventChan%);
    
    'create a current change event chan
    GCrrChngEvnt% := CurrentChangeEvent(chancurrenttmp%,GChan%);
    AddChanToStartView(GCrrChngEvnt%);
       
    'prep cursors
    gotonext% := 1;
    SeqStartTHolder := 0;
    while (gotonext%) do
        CursorDelete(-1);
        
        'find the next current change event on curr change channel
        SeqStartTHolder := NextTime(GCrrChngEvnt%, SeqStartTHolder);
        
        'if no more events break exit while
        if SeqStartTHolder=-1 then
            break
        endif;
        
        'put a cursor at the found event, this will be the sequence start
        CursorNew(SeqStartTHolder,1);
        CursorLabel(4, 1, "Seq Start");CursorLabelPos(1,10);
        
        'search in advance of the sequence start time, to find the end of the sequence
        SeqEndT := SeqStartTHolder;
        for j% := 1 to (GNumSteps%*2)-1 do
            SeqEndT := NextTime(GCrrChngEvnt%, SeqEndT);
        next;
        
        'put a cursor at what I is probably the sequence end
        '(but this will be off if there are extra events in the curr change channel 
        CursorNew(SeqEndT, 2);
        CursorLabel(4,2,"Seq End");CursorLabelPos(2,10);
        
        'Draw the screen around the found cursors
        RestoreStartView();
        XRange(SeqStartTHolder-35,SeqEndT+35);
        
        'Change the sequence end if necessary
        ChngSqnEnd(GCrrChngEvnt%, SeqEndT);
        
        'Make measures for each step in the series
        if isokay% then
            docase 
                case(GNumSteps% = 1) then
                stepstart := SeqStartTHolder;
                stepend := SeqEndT;
                mkmeasurs(GChan%, chancurrenttmp%, GEventChan%);
                printmeasurs(GOutResistVh%[i%],1,GNumSteps%);
                SeqStartTHolder := SeqEndT
                else
                    for j% := 1 to GNumSteps% do
                        docase
                            case (j%=1) then
                                stepstart := SeqStartTHolder;
                                stepend := NextTime(GCrrChngEvnt%,stepstart);
                            case (j%=GNumSteps%) then
                                stepstart := NextTime(GCrrChngEvnt%, stepend);
                                stepend := SeqEndT;
                            else
                                stepstart := NextTime(GCrrChngEvnt%,stepend);
                                stepend := NextTime(GCrrChngEvnt%,stepstart);
                        endcase
                        mkmeasurs(GChan%, chancurrenttmp%, GEventChan%);
                        printmeasurs(GOutResistVh%[i%],j%, GNumSteps%);
                    next
            endcase;
        endif
    wend
    View(GVt%);
    View(GOutResistVh%[i%]); FilePathSet(GDirString$); FileSaveAs(outresistname$,1); FileClose();
next

func FindRMP(LChan%)
    var LRmpHCursor%;
    var LRmp;
    ChanHide(-1);
    ChanShow(LChan%);
    LRmpHCursor% := HCursorNew(LChan%,-60);
    HCursorLabel(1, LRmpHCursor%);
    HCursorLabelPos(LRmpHCursor%, 0.9);
    Draw();
    Interact("Move Horz Cursor to line up with RMP",1023, 1,"&O Okay");
    LRmp := HCursor(LRmpHCursor%);
    RestoreStartView();
    return (LRmp);
end

proc ChngSqnEnd(GCrrChngEvnt%, SeqEndT)
    makeeventcursors(3);
    ToolbarSet(8,"&A add||add a spikes at add cursor", addspk%);
    ToolbarSet(7,"&E delone||del spk nearest del cursor1", delonespk%);
    ToolbarSet(6,"&U delbtwn||del all spks btwn two del cursors", delspksbtw%);
    ToolbarSet(5,"&F done||Don't count this guy, Im done", Fnsh%);    
    ToolbarSet(4,"&J back||del reverse seq end", SeqEndPre%);
    ToolbarSet(3,"&K frwd||del advance seq end", SeqEndNext%);
    ToolbarSet(2,"$&Q okay", Okay%);
    ToolbarEnable(1,1);
    Toolbar("",1);
end

'Sequence end chnging toolbar funcs'
    func Fnsh%()
        gotonext% := 0;
        isokay% := 0;
        return(0);
    end

    func SeqEndPre%()
        SeqEndT := LastTime(GCrrChngEvnt%, SeqEndT);
        Cursor(2, SeqEndT);
        Draw();
    return(1);
    end

    func SeqEndNext%()
        SeqEndT := NextTime(GCrrChngEvnt%, SeqEndT);
        Cursor(2, SeqEndT);
        Draw();
    return(1);
    end

    func Okay%()
    return(0);
    end
'Sequence end chnging toolbar funcs' 

proc mkmeasurs(chanvolts%,chancurrent%,chanspks%)
    vstprmp := ChanMeasure(chanvolts%,2,stepstart-avgover, stepstart);
    vstpi := ChanMeasure(GChan%,2,stepend-avgover, stepend);
    vstpdelt := vstpi - vstprmp;
    current := ChanMeasure(chancurrent%,2,stepend, stepstart);
    numspks% := ChanData(chanspks%, trsharry[], stepstart, stepend);
    if (numspks%) then 
        spklaten := NextTime(chanspks%, stepstart);
        fspkwdth := SpkWdth(chanvolts%, spklaten, GRMP, 0.63);
        spklaten := spklaten - stepstart;
    else
        spklaten := -1;
    endif
    'search for spikes
end

func SpkWdth(LChan%, LSpkPeakTime, RMP, AmpFrac)
    var HalfWindow := 0.1;
    var LeftHandStart := LSpkPeakTime - HalfWindow;
    var RightHandEnd := LSpkPeakTime + HalfWindow;
    var chndata[3000], LenData%, i%;
    var TimeLeftRiseThrough, TimeRightFallThrough;
    var PeakHeight, VThresh;
    var WdthAtThresh;
    PeakHeight:= ChanValue(LChan%,LSpkPeakTime);
    VThresh := ((PeakHeight - RMP) * AmpFrac) + RMP;
    LenData% := ChanData(LChan%, chndata[], LeftHandStart, LSpkPeakTime);
    var tmptime;
    for i% := LenData% to 0 step -1 do
        if chndata[i%]<VThresh then
            tmptime := BinSize(LChan%);
            tmptime := (LenData% - i%);
            TimeLeftRiseThrough :=  (LenData% - i%) * BinSize(LChan%);
            break
        endif;
    next;
    LenData% := ChanData(LChan%, chndata[], LSpkPeakTime, RightHandEnd);
    for i% := 0 to LenData% do
        if chndata[i%]<VThresh then
            TimeRightFallThrough :=  i% * BinSize(LChan%);
            break
        endif;
    next;
    WdthAtThresh := TimeLeftRiseThrough + TimeRightFallThrough;
    return (WdthAtThresh);
end
    
proc printmeasurs(outvh%, i%, howmanysteps%)    
    View(outvh%);
    if (i% = 1) then
        Print("%.4f,",SeqStartTHolder);
        Print("%.4f,",SeqEndT);
    endif
    Print("%.4f,",stepstart);
    Print("%.4f,",stepend);        
    Print("%.4f,",vstprmp);
    Print("%.4f,",vstpi);
    Print("%.4f,",vstpdelt);
    Print("%.4f,",current);
    Print("%d,",numspks%);
    Print("%.4f,",spklaten);
    Print("%.4f,",fspkwdth);
    if (i% = howmanysteps%) then
        Print("\n");
    endif
    View(GVt%);
end            

'This func deletes the mean of the current moniter channel 
'(to avoid sign problems with a holding current), then takes the 
'abs value of the of the demeaned channel so a single threshold cateches 
'both positive and negative
func makerectslpchan(chan%)
    var expr$, vchan%;
    vchan% := MemChan(0, chan%);
    MemImport(vchan%, chan%, 0.0, MaxTime()); 'Create channel copy
    ChanProcessAdd(vchan%,3,0.001);
    ChanProcessAdd(vchan%,0);
    return vchan%;
end

'This func cuts channel title: either cuts last char if it is white
'or cuts everything after(including) two contiguous whites.
func leftunblnkchan$(chan%)
    var chntit$, titlen%;
    chntit$ := ChanTitle$(chan%);
    titlen% := Len(chntit$);
    docase
        case (InStr(chntit$, " ") = (titlen%-1)) then
            chntit$ := Left$(chntit$, (titlen%-1));
        case (Instr(chntit$, "  ")) then
            titlen% := InStr(chntit$, "  ");
            chntit$ := Left$(chntit$, (titlen%-1));
    endcase
    return chntit$;
end

'''Print the header of the file'''
func PrntHeader(LNSteps%)
    var Lj%;
    for Lj% := 1 to LNSteps% do 
        if (Lj% = 1) then
            Print("seqstart,");
            Print("seqend,");
        endif
        Print("%s_%d%s","stpstart",Lj%,",");
        Print("%s_%d%s","stpend",Lj%,",");        
        Print("%s_%d%s","vstp_rmp",Lj%,",");
        Print("%s_%d%s","vstp_i",Lj%,",");
        Print("%s_%d%s","vstp_delt",Lj%,",");
        Print("%s_%d%s","crnt_mntr",Lj%,",");
        Print("%s_%d%s","num_spks",Lj%,",");
        Print("%s_%d%s","fspk_lat",Lj%,",");
        Print("%s_%d%s","fspk_wdth",Lj%,",");
        if (Lj% = LNSteps%) then
            Print("\n");
        endif
    next
end

'''Create and return an event channel with an event for any current step change'''
'''Just to be sane, pass in both the current channel, and its corresponding voltage chan'''
'''depends on makerectslpchan'''
func CurrentChangeEvent(LIChan%, LVChan%)
    var VirtLIChan%;
    var LOutEvent%;
    var LThresh;
    VirtLIChan% := makerectslpchan(chancurrenttmp%);
    HCursorDelete(-1);
    HCursorNew(VirtLIChan%);
    ChanShow(VirtLIChan%); ChanShow(LVChan%);
    Optimise(VirtLIChan%); Optimise(LVChan%);
    Draw(Cursor(0),120);
    FrontView(GVt%);
    Interact("Thresh",1023,1,"&O Okay");
    LThresh := HCursor(1);
    LOutEvent% := MemChan(2);
    MemImport(LOutEvent%,VirtLIChan%,0,MaxTime(),0,0.01,LThresh);
    return LOutEvent%;
end