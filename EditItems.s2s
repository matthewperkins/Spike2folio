'edit items

#include "include\basic_view.s2s"     'this will bring in two globals: GVt% and GChanList%[]

var TMarkFeature%, MarkFeature%, features%[10], FeatureCurs%;
var SnglSlctChn%[2];
var MinBurstInterval := 5; '5 seconds is good for excitability tests

'SELECT MARK CHANNEL FOR EDITING 
Interact("Select chan event chan to edit", 1023, 0, "&O Okay");
ChanList(SnglSlctChn%, 65536);
TMarkFeature% := SnglSlctChn%[1];
'check to see if selected channel is a marker channel
if (ChanKind(TMarkFeature%)=5) then
    MarkFeature% := CopyWave%(TMarkFeature%);
else
    MarkFeature% := MemChan(5);
    BurstMake(MarkFeature%,TMarkFeature%,0,MaxTime(),MinBurstInterval);
endif;
ChanTitle$(MarkFeature%, "EDITING");


'SELECT OTHER CHANNELS FOR VISUAL GUIDENCE
Interact("Select chans to see while messing around", 1023, 0, "&O Okay");
ChanList(features%[],65536);
ChanHide(-1);
ChanShow(features%[]);
Draw();

'use marker code 0 0 0 0 for condition start
var startcode%[4];
ArrConst(startcode%[], 0);

'use marker code 1 0 0 0 for condition END
var endcode%[4];
ArrConst(endcode%[], 0);
endcode%[0] := 1;

'SHOW CHANNEL, AND PUT LABELED CURSORS IN VIEW
ChanShow(MarkFeature%); 
CursorDelete(-1);
FeatureCurs% := CursorNew();
CursorLabel(4, FeatureCurs%,"Feature Cursor"); 
CursorLabelPos(FeatureCurs%,50);
makeeventcursors(3);

ToolbarClear();
ToolbarSet(14, "&U DlBtwn||Delete between del1 and del2", delspksbtw%);
ToolbarSet(13, "&N MkEnd||Make End: make the mark nrst featr crs an end", MkEnd%);
ToolbarSet(12, "&Y  MkStr||Make Start: make the mark nearest the feature cursor a start", MkStart%);
ToolbarSet(11 , "&j frwd||jump forward", nexttest%);
ToolbarSet(10 , "&k rvsr||jump backward", lasttest%);
ToolbarSet(9 , "&f frwd||draw forward", forwarddraw%);
ToolbarSet(8 , "&r rvsr||draw backward", backwarddraw%);
ToolBarSet(7 , "&e addSTART||Add Condition Start at Cursor", AddCondStart%);
ToolBarSet(6 , "&. addEND||Add a Condition End at Cursor", AddCondEnd%);
ToolBarSet(5 , "&i del||Delete last Feature Item before Feature Cursor", Del%);
ToolBarSet(1 , "&l save||save eventchannels and leave",outie%);
ToolbarEnable(1,1);
Toolbar("",1);

var ConditionName$;
ConditionName$ := Input$("Condition Name", "Condition Name");
ChanTitle$(MarkFeature%, ConditionName$);
MarkFeature% := ChanSave(MarkFeature%,0);
AddChanToStartView(MarkFeature%);
RestoreStartView();
    
'TOOLBAR FUNCTION FOR ADDING & RMVING PRO STARTS, ENDS AND RETR ENDS
func MkEnd%()
    var cur1, before, after, closest;
    cur1 := Cursor(FeatureCurs%);
    after := NextTime(MarkFeature%, cur1);
    before := LastTime(MarkFeature%, cur1);
    if ((after - cur1) < (cur1-before)) then 
        closest := after 
    else 
        closest := before 
    endif;
    if (cur1 - closest<4) then
        MarkEdit(MarkFeature%, closest, endcode%[]);
        return(1);
    else
        return(1);
    endif;
end

func MkStart%()
    var cur1, before, after, closest;
    cur1 := Cursor(FeatureCurs%);
    after := NextTime(MarkFeature%, cur1);
    before := LastTime(MarkFeature%, cur1);
    if ((after - cur1) < (cur1-before)) then 
        closest := after 
    else 
        closest := before 
    endif;
    if (cur1 - closest<4) then
        MarkEdit(MarkFeature%, closest, startcode%[]);
        return(1);
    else
        return(1);
    endif;
end
    
func forwarddraw%()
var ttmp, rngtmp;
    'FIND RELATIVE POSITIONS OF CURSORS
    var RelPosFeat, RelPosDel, RelPosDel2;
    RelPosFeat := FeatureCurs% - XLow();
    RelPosDel := Cursor(8) - XLow();
    RelPosDel2 := Cursor(9) - XLow();

    
    rngtmp := XHigh()-XLow();
    ttmp := XLow() + rngtmp*0.1;
    Cursor(FeatureCurs%,(ttmp+RelPosFeat));
    Cursor(8,(ttmp+RelPosDel));Cursor(9,(ttmp+RelPosDel2));
    Draw(ttmp);
return(1);
end

func backwarddraw%()
var ttmp, rngtmp;
    'FIND RELATIVE POSITIONS OF CURSORS
    var RelPosFeat, RelPosDel, RelPosDel2;
    RelPosFeat := FeatureCurs% - XLow();
    RelPosDel := Cursor(8) - XLow();
    RelPosDel2 := Cursor(9) - XLow();

    rngtmp := XHigh()-XLow();
    ttmp := XLow() - rngtmp*0.1;
    Cursor(FeatureCurs%,(ttmp+RelPosFeat));
    Cursor(8,(ttmp+RelPosDel));Cursor(9,(ttmp+RelPosDel2));
    Draw(ttmp);
return(1);
end

func AddCondStart%()
    var FeaCurTime;
    FeaCurTime := Cursor(FeatureCurs%);
    MemSetItem(MarkFeature%,0,FeaCurTime, startcode%[]);
    Draw();
    return(1);
end

func AddCondEnd%()
    var FeaCurTime;
    FeaCurTime := Cursor(FeatureCurs%);
    MemSetItem(MarkFeature%,0, FeaCurTime, endcode%[]);
    Draw();
    return(1);
end

func Del%()
    var FeaCurTime; var numitems%;
    FeaCurTime := Cursor(FeatureCurs%);
    MemDeleteTime(MarkFeature%, 0, FeaCurTime, 4);
    Draw();
return(1);
end

func delspksbtw%()
    MemDeleteTime(MarkFeature%,3,Cursor(8),Cursor(9));
    Draw();
return(1);
end

func nexttest%()
    'want to save cursor position relative to window
    'then redraw them at the same relative position after jumping window
    var RelPosFeat, RelPosDel, RelPosDel2;
    RelPosFeat := FeatureCurs% - XLow();
    RelPosDel := Cursor(8) - XLow();
    RelPosDel2 := Cursor(9) - XLow();

    'want to save window position relative to the start of the test
    'then redraw new window at same relative position
    'if there is no exct test start mark in view, default to 20 % offset
    var RelPosWin, rngtmp;
    rngtmp := XHigh() - XLow();
    RelPosWin := XLow() - NextTime(MarkFeature%, XLow(), startcode%);
    if (Abs(RelPosWin) > rngtmp) then
        RelPosWin := rngtmp * -0.2;
    endif;

    'find next time and draw window and cursors
    var ttmp;
    ttmp := GetNextExctCode(MarkFeature%, XLow(), startcode%);
    ttmp := GetNextExctCode(MarkFeature%, ttmp, startcode%);
    ttmp := ttmp + RelPosWin;
    Cursor(FeatureCurs%,(ttmp+RelPosFeat));
    Cursor(8,(ttmp+RelPosDel));Cursor(9,(ttmp+RelPosDel2));
    Draw(ttmp);
    return(1);
end

func lasttest%()
    'want to save cursor position relative to window
    'then redraw them at the same relative position after jumping window
    var RelPosFeat, RelPosDel, RelPosDel2;
    RelPosFeat := FeatureCurs% - XLow();
    RelPosDel := Cursor(8) - XLow();
    RelPosDel2 := Cursor(9) - XLow();

    'want to save window position relative to the start of the test
    'then redraw new window at same relative position
    'if there is no exct test start mark in view, default to 20 % offset
    var RelPosWin, rngtmp;
    rngtmp := XHigh() - XLow();
    RelPosWin := XLow() - NextTime(MarkFeature%, XLow(), startcode%[]);
    if (Abs(RelPosWin) > rngtmp) then
        RelPosWin := rngtmp * -0.2;
    endif;


    'find next time and draw window and cursors
    var ttmp;
    ttmp := GetLastExctCode(MarkFeature%, XLow(), startcode%[]);
    Cursor(FeatureCurs%,(ttmp+RelPosFeat));
    Cursor(8,(ttmp+RelPosDel));Cursor(9,(ttmp+RelPosDel2));
    Draw(ttmp);
    return(1);
end

func outie%()
    ChanTitle$(MarkFeature%,"marked_feature"); 
    ChanSave(MarkFeature%,-1);
    return(0);
end

func CopyWave%(chan%) 
    var mc%;
    mc% := MemChan(0, chan%);                'Create waveform channel
    if mc%>0 then                            'Created OK?
       ChanComment$(mc%, "Copy of channel "+Str$(chan%));
       MemImport(mc%, chan%, 0, MaxTime());  'Copy data
    endif;
    return mc%; 'Return the new memory channel number
end;

func GetNextExctCode(chan%, time, code%[])
    var nextcode%[4];
    var codematch% := 1; 'codematch will be zero when match found
    while (codematch%=1) do
        time := NextTime(chan%,time,nextcode%);
        ArrSub(nextcode%[], code%[]);
        codematch% := ArrSum(nextcode%[]);
        if (time=-1) then break endif;
    wend;
    return time
end

func GetLastExctCode(chan%, time, code%[])
    var nextcode%[4];
    var codematch% := 1; 'codematch will be zero when match found
    while (codematch%=1) do
        time := LastTime(chan%,time,nextcode%);
        ArrSub(nextcode%[], code%[]);
        codematch% := ArrSum(nextcode%[]);
        if (time=-1) then break endif;
    wend;
    return time
end

Proc makeeventcursors(n%)
    var i%, range := XHigh()-XLow();
    var divi, divn := n%;
    var startcurnum% := 9-n%;
    for i% := 1 to n% do
        divi := i%;
        CursorNew(XLow()+(range*0.8*(divi/divn)), startcurnum%+i%);
    next
    CursorLabel(4, 8,"delete1"); CursorLabelPos(2,20);
    CursorLabel(4, 9,"delete2"); CursorLabelPos(3,20);
end
