'SCRIPT TO measure current in a voltage clamp experiment.';
'MUST have a designated channel as a current moniter, for each cell.';
var vt%;
var fname$, outcurrentname$, rdirstring$;

'these are globals that will set the measurements of the jump current, the steadstate current, and the tail currents';
var GPrepad := 0.002;
var GHoldCurrentTime := 0.020;
var GJumpPad := 0.001;
var GJumpCurrentTime := 0.01;
var GEndpad := 0.001;
var GSSCurrentTime := 0.01;
var GTailPad := 0.001;
var GTailCurrentTime := 0.01;
var vstprmp, vstpvlts, vstpdelt;
var holdcurrent, jumpcurrent, sscurrent, tailcurrent; 
var StepMarkerChan%;

'Handle Views';
vt% := View(0);  'Save the current view';
FrontView(vt%);
View(vt%);         'restore the original view';
DrawAll();

'script constants as of now';
var avgover,rwcnt%, restarttime;
avgover := 0.2;
rwcnt% := 0;
restarttime := Cursor(0); 'script starts cursor(0)';

'Get File Names Ready';
rdirstring$ := Print$("%s%s",FileName$(1),FileName$(2));
FilePathSet(rdirstring$);
rdirstring$ := Print$("%s%s", rdirstring$, "..\\indiv_cells\\B63\\vclamp_measures\\");
FilePathSet(rdirstring$);
fname$ := Print$("%s%s",FileName$(3),FileName$(4));

'Get how many signals to measure'; 
var howmanychans%, channame$;
howmanychans% := Input("How many chans have steps?", 1);

'try not to make any thing global, so need some
'variables for passing btwn functions, and for the toolbar actions'
var i%, chanindx%;
var GThresh, GRectSlopeChan%;
var GSelectedChans%[4]; '[0:cur chan],[1:volt chan],[2:-mark chan],[3:+markchan]';
var GNames$[2];   '0:channame$, [1:csvname]';
var GTimes[3][1000]; '[0][0]:events';
	    '[1][0]:numstarts';
	    '[1][1..numstarts], start1,start2, ...]';
	    '[2][0]:numends';
	    '[2][1..numends], end1, end2, ...]';
var GCurrents[10][10][100]; '[0][0][0]:nums of chans';
	    '[c%][0][0]:num types of measurs,on chan c%';
	    '[c%][t%][0]:num of t% type of measure';
	    '[c%][t%][1..10]:first..tenth of t% type measure, on c%';
var GVoltages[10][10][100]; '[0][0][0]:nums of chans';
	    '[c%][0][0]:num types of measurs,on chan c%';
	    '[c%][t%][0]:num of t% type of measure';
	    '[c%][t%][1..10]:first..tenth of t% type measure, on c%';x

'this big ugly loop is main';
for i% := 1 to howmanychans% do
    chanindx% := i% - 1;
    SelectChans(GSelectedChans%[],i%); 'proc, adds values to selectedchans';
    MkNames(GNames$[],GSelectedChans%[]);
    MakeMarks(GTimes[][], GSelectedChans%[]); 'proc, adds values to times';
    TakeMeasures(GCurrents[][][], GVoltages[][][], GTimes[][], GSelectedChans%[], chanindx%);
    WriteFiles(GCurrents[][][], GTimes[][], GVoltages[][][], chanindx%);
next;

proc SelectChans(lchans%[],indx%)
  var chancur%, chanvolt%;
  chancur% := Input("Measure which current channel?", indx%+1);
  chanvolt% := Input("Which channel is the voltage?", indx%);
  lchans%[0] := chancur%;
  lchans%[1] := chanvolt%;
  lchans%[2] := MemChan(3);
  lchans%[3] := MemChan(2);
end;

proc MkNames(lnames$[],lchans%[])
  var channame$, csvname$;
  channame$ := leftunblnkchan$(lchans%[0]);
  csvname$:= "vclamp.csv";
  csvname$ := Print$("%s_%s_%s",fname$,channame$,outcurrentname$);
  lnames$[0] := channame$;
  lnames$[1] := csvname$;
end;

proc MakeMarks(ltimes[][],lchans%[])
    GRectSlopeChan% := MakeRectSlpChan(lchans%[1]);
    GThresh := SetAThresh(GRectSlopeChan%);
    CursorVisible(0);
    CursorActive(0, 4, GRectSlopeChan%, 0.01, "", "", GThresh);  '8 falling thresh, 7 rising threshold';
    ChanShow(lchans%[2]); ChanShow(lchans%[3]);
    ToolbarSet(8,"&A addStr||add a step start at cursor", addstepstart%);
    ToolbarSet(7,"&E delone||del a step start near cursor", delstepstart%);
    ToolbarSet(6,"&O addEnd||add a step end at cursor", addstepend%);
    ToolbarSet(5,"&U delEnd||del a step end near cursor1", delstepend%);
    ToolbarSet(4,"&I DRAW||draw around cursor", drawcrs%);
    ToolbarSet(3, "&C ChngTrsh||change the search threshhald", chngthrsh%);
    ToolbarSet(2,"$&Q quit", outie%);
    ToolbarEnable(1,1);
    Toolbar("",511);
    ltimes[0][0] := ChanData(lchans%[3],ltimes[1][1:999],0, MaxTime()); 'get starts';
    ltimes[1][0] := ltimes[0][0];
    ltimes[2][0] := ChanData(lchans%[2],ltimes[2][1:999],0,MaxTime()) 'get ends';
end
    
proc TakeMeasures(lcurrents[][][], lvoltages[][][], ltimes[][], lchans%[], cindx%)
  var holdvoltage,jumpvoltage,ssvoltage,tailvoltage;
  var holdcurrent,jumpcurrent,sscurrent,tailcurrent;
  var lvoltchan%, lcurchan%, numstps% := ltimes[0][0];
  var stepstart, stepend;
  var j% := 1;
  ArrConst(lcurrents[cindx%][][0],numstps%);
  for j% := 1 to numstps% do; 'iterate through num events';
      stepstart := ltimes[1][j%];
      stepend := ltimes[2][j%];
      lcurchan% := lchans%[0];
      lvoltchan% := lchans%[1];
      holdcurrent := ChanMeasure(lcurchan%,2,stepstart - GPrePad - GHoldCurrentTime, stepstart - GPrePad);
      holdvoltage := ChanMeasure(lvoltchan%,2,stepstart - GPrePad - GHoldCurrentTime, stepstart - GPrePad);
      jumpcurrent := ChanMeasure(lcurchan%,2,stepstart + GJumpPad, stepstart + GJumpPad + GJumpCurrentTime);
      jumpvoltage := ChanMeasure(lvoltchan%,2,stepstart + GJumpPad, stepstart + GJumpPad + GJumpCurrentTime);
      sscurrent := ChanMeasure(lcurchan%,2,stepend - GEndpad - GSSCurrentTime, stepend - GEndpad);
      ssvoltage := ChanMeasure(lvoltchan%,2,stepend - GEndpad - GSSCurrentTime, stepend - GEndpad);
      tailcurrent := ChanMeasure(lcurchan%,2,stepend + GTailPad, stepend + GTailPad + GTailCurrentTime);
      tailvoltage := ChanMeasure(lvoltchan%,2,stepend + GTailPad, stepend + GTailPad + GTailCurrentTime);
      lcurrents[cindx%][1][j%] := holdcurrent;
      lcurrents[cindx%][2][j%] := jumpcurrent;
      lcurrents[cindx%][3][j%] := sscurrent;
      lcurrents[cindx%][4][j%] := tailcurrent;
      lvoltages[cindx%][1][j%] := holdvoltage;
      lvoltages[cindx%][2][j%] := jumpvoltage;
      lvoltages[cindx%][3][j%] := ssvoltage;
      lvoltages[cindx%][4][j%] := tailvoltage;
  next;
end

proc WriteFiles(lcurrents[][][], ltimes[][], lvoltages[][][], cindx%)
    var csvfilevh%;
    csvfilevh% := FileNew(1);
    printmeasurs(csvfilevh%, lcurrents[cindx%][][], ltimes[][], lvoltages[cindx%][][]);
    View(csvfilevh%);
    FrontView(vt%);
    View(csvfilevh%);
    FilePathSet(rdirstring$);
    FileSaveAs(outcurrentname$,1);
    FileClose();
end

proc printmeasurs(outvh%, llcurrents[][], lltimes[][], llvoltages[][])
    var lnumsteps% := lltimes[0][0];
    view(outvh%);
    Print("step_starts,");
    Print("%.4f,",lltimes[1][1:lnumsteps%]);
    Print("\nstep_ends,");
    Print("%.4f,",lltimes[2][1:lnumsteps%]);
    Print("\nhold_voltage,");
    Print("%.4f,",llvoltages[1][1:lnumsteps%]);
    Print("\njump_voltage,");
    Print("%.4f,",llvoltages[2][1:lnumsteps%]);
    Print("\nss_voltage,");
    Print("%.4f,",llvoltages[3][1:lnumsteps%]);
    Print("\ntail_voltage,");
    Print("%.4f,",llvoltages[4][1:lnumsteps%]);
    Print("\nhold_current,");
    Print("%.4f,",llcurrents[1][1:lnumsteps%]);
    Print("\njump_current,");
    Print("%.4f,",llcurrents[2][1:lnumsteps%]);
    Print("\nss_current,");
    Print("%.4f,",llcurrents[3][1:lnumsteps%]);
    Print("\ntail_current,");
    Print("%.4f,",llcurrents[4][1:lnumsteps%]);
end            

'This func deletes the mean of the a channel ';
'(to avoid sign problems with a holding current), then takes the ';
'abs value of the of the demeaned channel so a single threshold cateches ';
'both positive and negative';
func makerectslpchan(chan%)
    var expr$, vchan%;
    vchan% := MemChan(0, chan%);
    MemImport(vchan%, chan%, 0.0, MaxTime()); 'Create channel copy';
    ChanProcessAdd(vchan%,3,0.001);
    ChanProcessAdd(vchan%,0);
    return vchan%;
end

'This func cuts channel title: either cuts last char if it is white';
'or cuts everything after(including) two contiguous whites.';
func leftunblnkchan$(chan%)
    var chntit$, titlen%;
    chntit$ := ChanTitle$(chan%);
    titlen% := Len(chntit$);
    docase
        case (Instr(chntit$, "  ")) then
            titlen% := InStr(chntit$, "  ");
            chntit$ := Left$(chntit$, (titlen%-1));
        case (InStr(chntit$, " ") = (titlen%-1)) then
            chntit$ := Left$(chntit$, (titlen%-1));
        endcase
    return chntit$;
end

'sets chan title';
proc setchantitle(inchan%, outchan%, appendstring$)
    var tmpchantit$;
    tmpchantit$ := ChanTitle$(inchan%);
    tmpchantit$ := Print$("%s_%s",Left$(tmpchantit$,5),appendstring$);
    ChanTitle$(outchan%,tmpchantit$);
end

func SetAThresh(chan%)
  var lthrsh, toolongtime:=120;
  HCursorDelete(-1);
  HCursorNew(chan%);
  ChanShow(chan%);
  Optimise(chan%);
  FrontView(vt%);
  if MaxTime()<toolongtime then toolongtime:= MaxTime(); endif;
  Draw(Cursor(0),toolongtime);
  Interact("Thresh",511);
  lthrsh := HCursor(1);
  return lthrsh;
end


'Spike editing toolbar functions';
func addstepstart%()
    MemSetItem(GSelectedChans%[3],0, Cursor(0));
return(1);
end

func delstepstart%()
    MemDeleteTime(GSelectedChans%[3],0,Cursor(0),30);
    Draw();
return(1);
end

func addstepend%()
    MemSetItem(GSelectedChans%[2],0, Cursor(0));
return(1);
end

func delstepend%()
    MemDeleteTime(GSelectedChans%[2],0,Cursor(0),30);
    Draw();
return(1);
end


func outie%()
return(0);
end

func drawcrs%()
var rngtmp;
    rngtmp := XHigh()-XLow();
    Draw(Cursor(0)-rngtmp*0.2);
return(1);
end

func chngthrsh%()
    GThresh := HCursor(1);
    CursorActive(0, 4, GRectSlopeChan%, 0.01, "", "", GThresh);  '8 falling thresh, 7 rising threshold';
return(1);
end
