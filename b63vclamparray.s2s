'SCRIPT TO measure current in a voltage clamp experiment.';
'MUST have a designated channel as a current moniter, for each cell.';
'astring';
'astring';';astring';
var start, iend, vt%;
var thresh, seqstart, seqend;
var numspks%, spklaten, trsharry[200];
var gotonext%, isokay%;
var fname$, outcurrentname$, rdirstring$, outcurrentvh%[10],starts%[10],stops%[10],vchan%;
var stepstart, stepend;
var isoneelect%;
var i%,j%;

'these are globals that will set the measurements of the jump current, the steadstate current, and the tail currents';
var GPrepad := 0.002;
var GHoldCurrentTime := 0.020;
var GJumpPad := 0.001;
var GJumpCurrentTime := 0.01;
var GEndpad := 0.001;
var GSSCurrentTime := 0.01;
var GTailPad := 0.001;
var GTailCurrentTime := 0.01;
var vstprmp, vstpvlts, vstpdelt;
var holdcurrent, jumpcurrent, sscurrent, tailcurrent; 
var StepMarkerChan%;

'Handle Views';
vt% := View(0);  'Save the current view';
FrontView(vt%);
View(vt%);         'restore the original view';
DrawAll();

'script constants as of now';
var avgover,rwcnt%, restarttime;
avgover := 0.2;
rwcnt% := 0;
restarttime := Cursor(0); 'script starts cursor(0)';

'Get File Names Ready';
rdirstring$ := Print$("%s%s",FileName$(1),FileName$(2));
FilePathSet(rdirstring$);
rdirstring$ := Print$("%s%s", rdirstring$, "..\\indiv_cells\\B63\\vclamp_measures\\");
FilePathSet(rdirstring$);
fname$ := Print$("%s%s",FileName$(3),FileName$(4));

'Get how many signals to measure'; 
var howmanychans%, channame$;
howmanychans% := Input("How many chans have steps?", 1);
outcurrentvh%[0] := howmanychans%;

'outcurrMat is only for one channel pleas';
var outcurrMat%;
starts%[0] := howmanychans%;
stops%[0] := howmanychans%;

'try not to make any thing global, so need some
variables for passing btwn functions, and for the toolbar actions'
var i%, chanindx%;
var GThresh;
var GSelectedChans%[3]; '[0:cur chan],[1:volt chan],[2:-mark chan],[3:+markchan]';
var GNames$[2];   '0:channame$, [1:csvname]';
var GTimes[3][1000]; '[0][0]:events';
	    '[1][0]:numstarts';
	    '[1][1..numstarts], start1,start2, ...]';
	    '[2][0]:numends';
	    '[2][1..numends], end1, end2, ...]';
var GCurrents[10][10][100]; '[0][0][0]:nums of chans';
	    '[c%][0][0]:num types of measurs,on chan c%';
	    '[c%][t%][0]:num of t% type of measure';
	    '[c%][t%][1..10]:first..tenth of t% type measure, on c%';

'this big ugly loop is main';
for i% := 1 to howmanychans% do
    chanindx% := i% - 1;
    SelectChans(GSelectedChans%[]); 'proc, adds values to selectedchans';
    MkNames(GNames$[],GSelectedChans%[])
    MakeMarks(GTimes[], GSelectedChans[]%); 'proc, adds values to times';
    TakeMeasures(GCurrents[], GTimes[], GSelectedChans%, chanindx%);
    WriteFiles(GCurrents[]);
next;

proc SelectChans(lchans%[],indx%)
  var chancur%, chanvolt%;
  chancur% := Input("Measure which current channel?", indx%+1);
  chanvolt% := Input("Which channel is the voltage?", indx%);
  lchans%[0] := chancur%;
  lchans%[1] := chanvolt%;
  lchans%[2] := MemChan(3);
  lchans%[3] := MemChan(2);
end;

proc MkNames(lnames$[],lchans%[])
  var channame$, csvname$;
  channame$ := leftunblnkchan$(lchan%[0]);
  csvname$:= "vclamp.csv";
  csvname$ := Print$("%s_%s_%s",fname$,channame$,outcurrentname$);
  lnames[0] := channame$;
  lnames[1] := csvname$;
end;

proc MakeMarks(ltimes[],lchans%[])
    var rectslopechan, thresh%
    rectsolpechan% := MakeRectSlpChan(lchans%[1]);
    GThresh := SetAThresh(rectslopechan%)
    CursorDelete(-1);
    CursorActive(0, 4, vchan%, 0.01, "", "", thresh);  '8 falling thresh, 7 rising threshold';
    ToolbarSet(8,"&A addStr||add a step start at cursor", addstepstart%);
    ToolbarSet(7,"&H delone||del a step start near cursor", delstepstart%);
    ToolbarSet(6,"&T addEnd||add a step end at cursor", addstepstart%);
    ToolbarSet(5,"&S delEnd||del a step end near cursor1", delstepstart%);
    ToolbarSet(4,"&I DRAW||draw around cursor", drawcrs%);
    ToolbarSet(3, "&C ChngTrsh||change the search threshhald", chngthrsh%);
    ToolbarSet(2,"$&Q quit", outie%);
    ToolbarEnable(1,1);
    Toolbar("",1);
    ltimes[0][0] := ChanData(lchans%[3],ltimes[1][]); 'get starts';
    ChatData(lchans%[2],ltimes[2][]) 'get ends';
end
    
proc TakeMeasures(lcurrents[], ltimes[], lchans%[], cindx%)
  var vrmp,vstp,holdcurrent,jumpcurrent,sscurrent,tailcurrent;
  var lvoltchan%, lcurchan%, numstps% := ltimes[0][0];
  var stepstart, stepend;
  var j% := 1;
  lcurrents[cindx%][0][0] := numstps%;
  for j% := 1 to numstps%; 'iterate through num events';
      stepstart := ltimes[1][j%];
      stepend := ltime[2][j%];
      lcurchan% := lchans%[0];
      lvoltchan% := lchans%[1];
      vrmp := ChanMeasure(lchans%[1],2,stepstart-avgover, stepstart);
      vstp := ChanMeasure(lchans%[1],2,stepend-avgover, stepend);
      vdelt := vstp - vrmp;
      holdcurrent := ChanMeasure(lcurchan%,2,stepstart - GPrePad - GHoldCurrentTime, stepstart - GPrePad);
      jumpcurrent := ChanMeasure(lcurchan%,2,stepstart + GJumpPad, stepstart + GJumpPad + jumpcurrenttime);
      sscurrent := ChanMeasure(chancurrent%,2,stepend - GEndpad - GSSCurrentTime, stepend - GEndpad);
      tailcurrent := ChanMeasure(chancurrent%,2,stepend + GTailPad, stepend + G  TailPad + GTailCurrentTime);
      lcurrents[cindx%][1][j%] := holdcurrent;
      lcurrents[cindx%][2][j%] := jumpcurrent;
      lcurrents[cindx%][3][j%] := sscurent;
      lcurrents[cindx%][4][j%] := tailcurrent;
  next;
end

proc WriteFiles(currents[])
    var csvfilevh%;
    csvfilevh% := FileNew(1);
    View(csvfilevh%[i%]);
    FrontView(vt%);
    XRange(Cursor(0)-35,Cursor(0)+35);
    if isokay% then
       MemSetItem(starts%[i%], 0, Cursor(0));
       MemSetItem(stops%[i%], 0, Cursor(1));
                  
       docase 
           case(howmanysteps% = 1) then
           stepstart := seqstart;
           stepend := seqend;
           mkmeasurs(chanvoltagetmp%, chanmeastmp%,  chanspktmp%);
           printmeasurs(csvfilevh%[i%],1,howmanysteps%);
           if (isoneelect%) then CursorSearch(0); endif
           else
               CursorActive(1, 4, vchan%, "Cursor(0)+0.1", "Cursor(0)+30", "Cursor(0)", thresh); 'start finding cursor';
               CursorActive(0, 4, vchan%, 0.1, "", "", thresh);  'end finding cursor';
               for j% := 1 to howmanysteps% do
                   docase
                       case (j%=1) then
                           stepstart := seqstart;
                           stepend := CursorSearch(1);
                           CursorSearch(0);
                           CursorSearch(0);
                       case (j%=howmanysteps%) then
                           stepstart := Cursor(0);
                           stepend := seqend;
                           CursorSearch(0);
                       else
                           stepstart := Cursor(0);
                           stepend := CursorSearch(1);
                           CursorSearch(0);
                           CursorSearch(0);
                   endcase
                   mkmeasurs(chanvoltagetmp%, chanmeastmp%,  chanspktmp%);
                   printmeasurs(csvfilevh%[i%],j%, howmanysteps%);
               next
       endcase;
   endif
   gotonext% := Input("next?|", 1);
   if gotonext% then
           Cursor(0,Cursor(0)+1);
   endif
    wend
    View(vt%);
    View(csvfilevh%[i%]); FilePathSet(rdirstring$); FileSaveAs(outcurrentname$,1); FileClose();
next
ChanDelete(vchan%);
ChanDelete(starts%[]);
ChanDelete(stops%[]);
'ArrSum(rsltsarr[0:rwcnt%][], rlstmean[]);';


proc printmeasurs(outvh%, i%, howmanysteps%)    
    View(outvh%);
    if (i% = 1) then
        Print("%.4f,",seqstart);
        Print("%.4f,",seqend);
    endif
    Print("%.4f,",stepstart);
    Print("%.4f,",stepend);        
    Print("%.4f,",vstprmp);
    Print("%.4f,",vstpvlts);
    Print("%.4f,",vstpdelt);
    Print("%.4f,",holdcurrent);
    Print("%.4f,",jumpcurrent);
    Print("%.4f,",sscurrent);
    Print("%.4f,",tailcurrent);
    if (i% = howmanysteps%) then
        Print("\n");
    endif
    View(vt%);
end            

'This func deletes the mean of the current moniter channel ';
'(to avoid sign problems with a holding current), then takes the ';
'abs value of the of the demeaned channel so a single threshold cateches ';
'both positive and negative';
func makerectslpchan(chan%)
    var expr$, vchan%;
    vchan% := MemChan(0, chan%);
    MemImport(vchan%, chan%, 0.0, MaxTime()); 'Create channel copy';
    ChanProcessAdd(vchan%,3,0.001);
    ChanProcessAdd(vchan%,0);
    return vchan%;
end

'This func cuts channel title: either cuts last char if it is white';
'or cuts everything after(including) two contiguous whites.';
func leftunblnkchan$(chan%)
    var chntit$, titlen%;
    chntit$ := ChanTitle$(chan%);
    titlen% := Len(chntit$);
    docase
        case (Instr(chntit$, "  ")) then
            titlen% := InStr(chntit$, "  ");
            chntit$ := Left$(chntit$, (titlen%-1));
        case (InStr(chntit$, " ") = (titlen%-1)) then
            chntit$ := Left$(chntit$, (titlen%-1));
        endcase
    return chntit$;
end

'This function finds the spikes from the channel of interest, letting';
'user select thresholds with a cursor.';
func findspkpeak(n%, millitau)
    var eventchantmp%, tmpthresh;
    var sectau := millitau/1000;
    var append$ := "spk";
    ChanHide(-1); ChanShow(n%);
    HCursorDelete(-1);
    HCursorNew(n%); HCursorNew(n%);
    Interact("move cursors",2);
    HCursorRenumber();
    tmpthresh := HCursor(2) - HCursor(1);
    eventchantmp% := MemChan(2);
    MemImport(eventchantmp%, n%, 0, MaxTime(n%), 0, sectau, tmpthresh);
    setchantitle(n%, eventchantmp%, append$);
    return eventchantmp%;
end

'sets chan title';
proc setchantitle(inchan%, outchan%, appendstring$)
    var tmpchantit$;
    tmpchantit$ := ChanTitle$(inchan%);
    tmpchantit$ := Print$("%s_%s",Left$(tmpchantit$,5),appendstring$);
    ChanTitle$(outchan%,tmpchantit$);
end

func SetAThresh(chan%)
  var lthrsh;
  HCursorDelete(-1);
  HCursorNew(chan%);
  ChanShow(chan%);
  Optimise(chan%);
  Draw(Cursor(0),120);
  FrontView(vh%);
  Interact("Thresh",2);
  thresh := HCursor(1);
  return lthrsh;
end


'Spike editing toolbar functions';
func addstepstart%()
    MemSetItem(GSelectedChans%[3],0, Cursor(0));
return(1);
end

func delstepstart%()
    MemDeleteTime(GSelectedChans%[3],0,Cursor(0),30);
    Draw();
return(1);
end

func addstepend%()
    MemSetItem(GSelectedChans%[2],0, Cursor(0));
return(1);
end

func delstepend%()
    MemDeleteTime(GSelectedChans%[2],0,Cursor(0),30);
    Draw();
return(1);
end


func outie%()
return(0);
end

func drawcrs%()
var rngtmp;
    rngtmp := XHigh()-XLow();
    Draw(Cursor(0)-rngtmp*0.2)
return(1);

func chngthrsh%()
var lthrsh
  HCursorDelete(-1);
  HCursorNew(GSelectedChans%[1]);
  ChanShow(GSelectedChans%[1]);
  Optimise(GSelectedChans%[1]);
  Draw(Cursor(0),120);
  FrontView(vh%);
  Interact("Thresh",2);
  lthrsh := HCursor(1);
  GThresh := lthrsh;
return lthrsh;
