'to count spikes for cells with big platow potentials, it may work well to create a mem channel
'with a slope calculation, and then count events off this channel, this will neccisate counting 
'times on the slope channel, and then finding the voltage at that time on the real channel.
'to accurately find the peak voltage, use time of the zero crossing folloing the peak in the slope channel.
'the array that holds the spike times should hold only this zero crossing time.

var enstimchan%, enstimtimes, enstimVs1, i2, bn2, rn;
var howmanychan%, whichchan%[10],outchan%[10];
var pip1[2000],    pip2[2000],    pip3[2000],    pip4[2000];    'use to hold spiketimes
var pip1sV[2000],  pip2sV[2000],  pip3sV[2000],  pip4sV[2000];  'use to hold spikevoltages
var pip1rmp[2000], pip2rmp[2000], pip3rmp[2000], pip4rmp[2000]; 'use to hold rmps
var nrvstim[2000];                                              'use to hold nerve stim times
var stimpostpadgram;                                            'set post stimulus time to drop for neurograms
var stimpostpadpip;                                             'set post stimulus time to drop for sharp pipettes
var piprmppre;
var startt, endt;                                               'for designating the portion of time to run over.
var chanlist%[20];
var havestimchan%;

'SET CONTANSTS
piprmppre:= 0.2; 'time before current pulse that starts rmp average

'HANDLE VIEWS
var viewtemp%;
viewtemp% := View(0);  'Save the current view
View(viewtemp%);         'restore the original view
DrawAll();
FrontView(viewtemp%);
ChanList(chanlist%, 0x800);


'DELIMIT REGION, interact to place cursors bounding the region want to analyse.
CursorDelete(-1);           'Delete all cursors.
CursorNew();                'Create new cursor in middle of view.
CursorNew();                'Create new cursor in middle of view.
Interact("DRAG THE TWO CURSORS TO DELIMIT YOUR TIME????? THEN PRESS THE TINY OKAY BUTTON!!!!!", 2);
havestimchan% := Input("Do you want to delete spikes near your stimulus?", 1);
startt := Cursor(1);
endt := Cursor(2);
if (havestimchan%) then
    enstimchan%:= Input("What channel\n is enstim command volt?", 7);
endif;

'FOR EACH CHAN make slope mem chan, count events, 
howmanychan% := Input("how many channels?", 4);
FillBigArray(howmanychan%+2);
var eventchantmpstart%, spksokay% := 1;

Proc FillBigArray(n%)
    var bigarray[n%][20000];
    var itermessage$, i%, whichchantmp%,j%;
    var enthresh, spktmstmp, spkvltstmp, rmptmp, slopchantmp%, eventchantmpend%, tmpthresh;
    var slopeorno%, variablecount%:=0,  tau;
    for i% := 1 to howmanychan% do
        if (havestimchan% and i% = 1) then
            whichchantmp% := enstimchan%;
            whichchan%[i%] := enstimchan%;
            slopchantmp% := whichchantmp%;
            eventchantmpstart% := findstimulusstart(whichchantmp%);
            eventchantmpend% := findstimulusend(whichchantmp%);
            ChanData(eventchantmpstart%,bigarray[0][],startt, endt);
            ChanData(eventchantmpend%,bigarray[1][],startt, endt);
        endif;
        itermessage$   := Print$("%s", "tell me the next channel");
        whichchantmp%   := Input(itermessage$,i%-1);
        whichchan%[i%] := whichchantmp%;
        while (spksokay%) do
            slopeorno% := Input("compute spikes by peak(1), slope(2), or threshold crossing(3)?", 1);
            docase
                case (slopeorno%=1) then
                    tau := Input("give a tau in millisec \n(approx 2 x the spike dur works well)\n e.g. for b8, 8-10(ms)\n for b4/5 3ms", 3);
                    eventchantmpstart% := findspkpeak(whichchantmp%, tau);
                case (slopeorno%=2) then
                    tau := Input("give a tau in millisec \n(approx 2 x the spike dur works well)\n e.g. for b8, 8-10(ms)\n for b4/5 3ms", 3);
                    eventchantmpstart% := findspksslp(whichchantmp%, tau);
                case (slopeorno%=3) then
                    eventchantmpstart% := findspkthrsh(whichchantmp%);
            endcase
            if (havestimchan%) then
                for j% := 0 to len(bigarray[0][])-1 do
                    MemDeleteTime(eventchantmpstart%, 3, (bigarray[0][j%]-0.002), (bigarray[1][j%]+0.002));
                next
            endif;
            ChanData(eventchantmpstart%,bigarray[i%+1][],startt, endt);
            whichchan%[0] :=  whichchan%[0] + 1;
            ChanHide(-1); ChanShow(whichchantmp%); ChanShow(eventchantmpstart%);
            spksokay% := Interact("how does this look?",2,0,"&Y Good||accept the spike theresh and move on to edit individual events","&N Bad||reject spike thresh, and try again");
            if (spksokay%=1) then
            makeeventcursors(3);
                ToolbarSet(8,"&F Forward||Jump view and cursors forward", forwarddraw%);
                ToolbarSet(7,"&R Backward||Jump view and cursors backward", backwarddraw%);
                ToolbarSet(6,"&A add||add a spikes at add cursor", addspk%);
                ToolbarSet(5,"&E delone||del spk nearest del cursor1", delonespk%);
                ToolbarSet(4,"&U delbtwn||del all spks btwn two del cursors", delspksbtw%);
                ToolbarSet(3,"&P oops||restart spike detection", oops%);
                ToolbarSet(2,"$&Q quit", outie%);
                ToolbarEnable(1,1);
                Toolbar("",1);
            endif;
            if (spksokay%=1) then break endif;
            ChanDelete(eventchantmpstart%);
        wend;
        DrawMode(eventchantmpstart%,6,1);
        outchan%[i%] := ChanSave(eventchantmpstart%,0); outchan%[0] += 1;
        ChanDelete(eventchantmpstart%);
        ChanHide(-1);
        ChanShow(chanlist%);
    next
    PrintLog(bigarray);
    ChanHide(-1);
    ChanShow(outchan%);
end

'Spike editing toolbar functions
func addspk%()
    MemSetItem(eventchantmpstart%,0, Cursor(1));
return(1);
end

func delonespk%()
    MemDeleteTime(eventchantmpstart%,0,Cursor(2),5);
    Draw();
return(1);
end

func delspksbtw%()
    MemDeleteTime(eventchantmpstart%,3,Cursor(2),Cursor(3));
    Draw();
return(1);
end

func oops%()
spksokay% := 2;
return(0);
end

func outie%()
return(0);
end

func forwarddraw%()
var ttmp, rngtmp;
    rngtmp := XHigh()-XLow();
    ttmp := XLow() + rngtmp*0.75;
    Cursor(1,(ttmp+rngtmp*0.2));Cursor(2,(ttmp+rngtmp*0.4));Cursor(3,(ttmp+rngtmp*0.6));
    Draw(ttmp);
return(1);
end

func backwarddraw%()
var ttmp, rngtmp;
    rngtmp := XHigh()-XLow();
    ttmp := XLow() - rngtmp*0.75;
    Cursor(1,(ttmp+rngtmp*0.2));Cursor(2,(ttmp+rngtmp*0.4));Cursor(3,(ttmp+rngtmp*0.6));
    Draw(ttmp);
return(1);
end

'End toolbar functions

Proc makeeventcursors(n%)
    var i%, range := XHigh()-XLow();
    var divi, divn := n%;
    CursorDelete(-1);
    for i% := 1 to n% do
        divi := i%;
        CursorNew(XLow()+(range*0.8*(divi/divn)));
    next
    CursorLabel(4, 1, "add"); CursorLabelPos(1,50);
    CursorLabel(4,2,"delete1"); CursorLabelPos(2,50);
    CursorLabel(4,3,"delete2"); CursorLabelPos(3,50);
end


func findstimulusstart(n%)
    var stimevent%, enthresh;
    var append$ := "sVNT";
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, startt, endt, 2, 0, enthresh);
    setchantitle(n%, stimevent%, append$);
    return stimevent%
end

func findstimulusend(n%)
    var stimevent%, enthresh;
    var append$ := "eVNT";
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, startt, endt, 3, 0, enthresh);
    setchantitle(n%, stimevent%, append$);
    return stimevent%
end

func findsixsigma(n%)
    var mean, sdd, thresh;
    mean := ChanMeasure(n%,2,startt,endt);
    sdd  := ChanMeasure(n%,12,startt,endt);
    thresh := mean + (6*sdd);
    return thresh;
end

func findspkpeak(n%, millitau)
    var eventchantmp%, tmpthresh;
    var sectau := millitau/1000;
    var append$ := "spk";
    ChanHide(-1); ChanShow(n%);
    HCursorDelete(-1);
    HCursorNew(n%); HCursorNew(n%);
    Interact("move cursors",2);
    HCursorRenumber();
    tmpthresh := HCursor(2) - HCursor(1);
    eventchantmp% := MemChan(2);
    MemImport(eventchantmp%, n%, startt, endt, 0, sectau, tmpthresh);
    setchantitle(n%, eventchantmp%, append$);
    return eventchantmp%;
end

func findspksslp(n%, millitau)
    var slopchantmp%, eventchantmp%, tmpthresh;
    var append$ := "spk";
    var sectau := millitau/1000;
    slopchantmp% := MemChan(0,n%);
    MemImport(slopchantmp%, n%, startt, endt);
    ChanProcessAdd((slopchantmp%),3, sectau); 'add a slope channel process 3, time contant for slope calculation is sampling interval about.  
    DrawMode(slopchantmp%,0);
    HCursorDelete(-1);
    HCursorNew(slopchantmp%); HCursorNew(slopchantmp%);
    ChanHide(-1); ChanShow(n%); ChanShow(slopchantmp%);
    Optimise(slopchantmp%);
    DrawAll();
    Interact("move cursors",2);
    HCursorRenumber();
    tmpthresh := HCursor(2) - HCursor(1);
    eventchantmp% := MemChan(2);
    MemImport(eventchantmp%, slopchantmp%, startt, endt, 0, 0.0001, tmpthresh);
    setchantitle(n%, eventchantmp%, append$);
    ChanDelete(slopchantmp%);
    return eventchantmp%;
end

func findspkthrsh(n%)
    var eventchantmp%, tmpthresh;
    var append$ := "spk";
    ChanHide(-1); ChanShow(n%);
    HCursorDelete(-1);
    HCursorNew(n%);
    Interact("move cursor",2);
    tmpthresh := HCursor(1);
    eventchantmp% := MemChan(2);
    MemImport(eventchantmp%, n%, startt, endt, 2, 0.002, tmpthresh);
    setchantitle(n%, eventchantmp%, append$);
    return eventchantmp%;
end

proc setchantitle(inchan%, outchan%, appendstring$)
    var tmpchantit$;
    tmpchantit$ := ChanTitle$(inchan%);
    tmpchantit$ := Print$("%s_%s",Left$(tmpchantit$,5),appendstring$);
    ChanTitle$(outchan%,tmpchantit$);
end
