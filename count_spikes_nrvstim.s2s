'to count spikes for cells with big platow potentials, it may work well to create a mem channel
'with a slope calculation, and then count events off this channel, this will neccisate counting 
'times on the slope channel, and then finding the voltage at that time on the real channel.
'to accurately find the peak voltage, use time of the zero crossing folloing the peak in the slope channel.
'the array that holds the spike times should hold only this zero crossing time.

var enstimchan%, enstimtimes, enstimVs1, i2, bn2, rn;
var howmanychan%, whichchan%[10],outchan%[10];
var pip1[2000],    pip2[2000],    pip3[2000],    pip4[2000];    'use to hold spiketimes
var pip1sV[2000],  pip2sV[2000],  pip3sV[2000],  pip4sV[2000];  'use to hold spikevoltages
var pip1rmp[2000], pip2rmp[2000], pip3rmp[2000], pip4rmp[2000]; 'use to hold rmps
var nrvstim[2000];                                              'use to hold nerve stim times
var stimpostpadgram;                                            'set post stimulus time to drop for neurograms
var stimpostpadpip;                                             'set post stimulus time to drop for sharp pipettes
var piprmppre;
var startt, endt;                                               'for designating the portion of time to run over.
var chanlist%[20];
var havestimchan%;

'SET CONTANSTS
piprmppre:= 0.2; 'time before current pulse that starts rmp average

'HANDLE VIEWS
var viewtemp%;
viewtemp% := View(0);  'Save the current view
View(viewtemp%);         'restore the original view
DrawAll();
FrontView(viewtemp%);
ChanList(chanlist%, 0x800);


'DELIMIT REGION, interact to place cursors bounding the region want to analyse.
CursorDelete(-1);           'Delete all cursors.
CursorNew();                'Create new cursor in middle of view.
CursorNew();                'Create new cursor in middle of view.
Interact("DRAG THE TWO CURSORS TO DELIMIT YOUR TIME????? THEN PRESS THE TINY OKAY BUTTON!!!!!", 2);
startt := Cursor(1);
endt := Cursor(2);

'FOR EACH CHAN make slope mem chan, count events, 
howmanychan% := Input("how many channels?", 4);
FillBigArray(howmanychan%+2);

Proc FillBigArray(n%)
    var bigarray[n%][20000];
    var itermessage$, i%, whichchantmp%,j%;
    var enthresh, spktmstmp, spkvltstmp, rmptmp;
    var slopchantmp%, eventchantmpstart%, eventchantmpend%, tmpthresh;
    var slopeorno%, variablecount%:=0, spksokay% := 1;
    for i% := 1 to howmanychan% do
        itermessage$   := Print$("%s", "tell me the next channel");
        whichchantmp%   := Input(itermessage$,i%-1);
        whichchan%[i%] := whichchantmp%;
        slopeorno% := Input("compute spikes from slope? 1 is yes", 1);
        while (spksokay%) do 
            if (slopeorno%) then
                eventchantmpstart% := findspksslp(whichchantmp%);
            else
                eventchantmpstart% := findspkthrsh(whichchantmp%);
            endif;
            ChanData(eventchantmpstart%,bigarray[i%+1][],startt, endt);
            whichchan%[0] :=  whichchan%[0] + 1;
            ChanHide(-1); ChanShow(whichchantmp%); ChanShow(eventchantmpstart%);
            spksokay% := Interact("how does this look?",2,0,"&Y Good||accept the spike theresh and move on","&N Bad||reject spike thresh, and try again");
            if (spksokay%=1) then break endif;
            ChanDelete(eventchantmpstart%);
        wend;
        DrawMode(eventchantmpstart%,6,1);
        outchan%[i%] := ChanSave(eventchantmpstart%,0); outchan%[0] += 1;
        ChanDelete(eventchantmpstart%);
        ChanHide(-1);
        ChanShow(chanlist%);
    next
    PrintLog(bigarray);
    ChanHide(-1);
    ChanShow(outchan%);
end


func findstimulusstart(n%)
    var stimevent%, enthresh;
    var append$ := "sVNT";
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, startt, endt, 2, 0, enthresh);
    setchantitle(n%, stimevent%, append$);
    return stimevent%
end

func findstimulusend(n%)
    var stimevent%, enthresh;
    var append$ := "eVNT";
    stimevent% := MemChan(2);
    enthresh := findsixsigma(n%);
    MemImport(stimevent%, n%, startt, endt, 3, 0, enthresh);
    setchantitle(n%, stimevent%, append$);
    return stimevent%
end

func findsixsigma(n%)
    var mean, sdd, thresh;
    mean := ChanMeasure(n%,2,startt,endt);
    sdd  := ChanMeasure(n%,12,startt,endt);
    thresh := mean + (6*sdd);
    return thresh;
end

func findspksslp(n%)
    var slopchantmp%, eventchantmp%, tmpthresh;
    var append$ := "spk";
    slopchantmp% := MemChan(0,n%);
    MemImport(slopchantmp%, n%, startt, endt);
    ChanProcessAdd((slopchantmp%),3,0.0006); 'add a slope channel process 3, time contant for slope calculation is sampling interval about.  
    DrawMode(slopchantmp%,0);
    HCursorDelete(-1);
    HCursorNew(slopchantmp%); HCursorNew(slopchantmp%);
    ChanHide(-1); ChanShow(n%); ChanShow(slopchantmp%);
    Optimise(slopchantmp%);
    DrawAll();
    Interact("move cursors",2);
    HCursorRenumber();
    tmpthresh := HCursor(2) - HCursor(1);
    eventchantmp% := MemChan(2);
    MemImport(eventchantmp%, slopchantmp%, startt, endt, 0, 0.0001, tmpthresh);
    setchantitle(n%, eventchantmp%, append$);
    ChanDelete(slopchantmp%);
    return eventchantmp%;
end

func findspkthrsh(n%)
    var eventchantmp%, tmpthresh;
    var append$ := "spk";
    ChanHide(-1); ChanShow(n%);
    HCursorDelete(-1);
    HCursorNew(n%); HCursorNew(n%);
    Interact("move cursors",2);
    HCursorRenumber();
    tmpthresh := HCursor(2) - HCursor(1);
    eventchantmp% := MemChan(2);
    MemImport(eventchantmp%, n%, startt, endt, 0, 0.0001, tmpthresh);
    setchantitle(n%, eventchantmp%, append$);
    return eventchantmp%;
end

proc setchantitle(inchan%, outchan%, appendstring$)
    var tmpchantit$;
    tmpchantit$ := ChanTitle$(inchan%);
    tmpchantit$ := Print$("%s_%s",Left$(tmpchantit$,5),appendstring$);
    ChanTitle$(outchan%,tmpchantit$);
end
